<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Haskell 教程 - Hello 编程语言</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700&family=JetBrains+Mono:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        * {
            font-family: 'Noto Sans SC', sans-serif;
        }
        .code-font {
            font-family: 'JetBrains Mono', monospace;
        }
        .gradient-text {
            background: linear-gradient(135deg, #60A5FA 0%, #A78BFA 50%, #F87171 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .syntax-card {
            background: linear-gradient(145deg, rgba(30, 41, 59, 0.8), rgba(15, 23, 42, 0.9));
            backdrop-filter: blur(10px);
            border: 1px solid rgba(148, 163, 184, 0.1);
        }
        .code-block {
            background: rgba(2, 6, 23, 0.9);
            border-left: 4px solid #3B82F6;
        }
        .highlight {
            background: rgba(59, 130, 246, 0.2);
            padding: 2px 4px;
            border-radius: 3px;
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-100 min-h-screen">
    <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
        <div class="flex flex-col lg:flex-row gap-8">
            <!-- Sidebar Navigation -->
            <aside class="lg:w-1/4">
                <div class="bg-slate-800/50 backdrop-blur-md rounded-xl p-6 sticky top-24 border border-slate-700">
                    <h3 class="text-lg font-bold mb-4 gradient-text">章节导航</h3>
                    <nav class="space-y-2">
                        <a href="#section-1" class="block py-2 px-3 text-slate-300 hover:bg-slate-700 hover:text-white rounded-lg transition-colors">1. Haskell 简介</a>
                        <a href="#section-2" class="block py-2 px-3 text-slate-300 hover:bg-slate-700 hover:text-white rounded-lg transition-colors">2. Haskell 基础语法</a>
                        <a href="#section-3" class="block py-2 px-3 text-slate-300 hover:bg-slate-700 hover:text-white rounded-lg transition-colors">3. Haskell 列表操作</a>
                        <a href="#section-4" class="block py-2 px-3 text-slate-300 hover:bg-slate-700 hover:text-white rounded-lg transition-colors">4. Haskell 函数式编程特性</a>
                        <a href="#section-5" class="block py-2 px-3 text-slate-300 hover:bg-slate-700 hover:text-white rounded-lg transition-colors">5. Haskell 类型系统</a>
                        <a href="#section-6" class="block py-2 px-3 text-slate-300 hover:bg-slate-700 hover:text-white rounded-lg transition-colors">6. Haskell IO 和副作用</a>
                    </nav>
                </div>
            </aside>

            <!-- Main Content -->
            <div class="lg:w-3/4">
                <!-- 1. Haskell 简介 -->
                <section id="section-1" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">1. Haskell 简介</span>
            </h2>
            
            <div class="language-content" data-lang="haskell">
                <h4 class="text-lg font-medium mb-4 text-green-400">Haskell - 优雅的纯函数式编程语言</h4>
                <p class="text-slate-300 mb-4">Haskell是一种静态类型的纯函数式编程语言，以其数学般的严谨性、强大的类型系统和惰性求值特性而闻名。它是函数式编程的典范，被广泛用于教学、研究和实际开发中，特别适合需要高度可靠性和正确性的应用。</p>
                
                <div class="bg-slate-800 rounded-xl p-6 syntax-card">
                    <h5 class="text-lg font-medium mb-4 text-green-300">Haskell 语言特点</h5>
                    <ul class="text-slate-300 list-disc pl-6 space-y-2">
                        <li>纯函数式编程范式</li>
                        <li>静态类型系统，支持类型推断</li>
                        <li>惰性求值策略</li>
                        <li>强大的模式匹配</li>
                        <li>类型类系统</li>
                        <li>单子（Monad）用于处理副作用</li>
                        <li>代数数据类型</li>
                        <li>高阶函数和柯里化</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- 2. Haskell 基础语法 -->
        <section id="section-2" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">2. Haskell 基础语法</span>
            </h2>
            
            <div class="language-content" data-lang="haskell">
                <div class="bg-slate-800 rounded-xl p-6 syntax-card mb-6">
                    <h5 class="text-lg font-medium mb-4 text-green-300">Hello World 示例</h5>
                    <p class="text-slate-300 mb-4">这是Haskell的经典Hello World程序，展示了Haskell的基本结构。main函数是程序的入口点，IO ()类型表示这是一个产生副作用的操作。</p>
                    <pre class="code-block p-4 rounded-lg overflow-x-auto"><code class="code-font text-slate-300">-- Hello World 程序
main :: IO ()
main = putStrLn "Hello, Haskell!"
</code></pre>
                </div>

                <div class="bg-slate-800 rounded-xl p-6 syntax-card mb-6">
                    <h5 class="text-lg font-medium mb-4 text-green-300">基本数据类型和表达式</h5>
                    <p class="text-slate-300 mb-4">Haskell支持多种基本数据类型，包括数值类型、布尔值、字符、字符串、列表和元组。这些数据类型构成了Haskell编程的基础。</p>
                    <pre class="code-block p-4 rounded-lg overflow-x-auto"><code class="code-font text-slate-300">-- 整数
42
-100

-- 浮点数
3.14
-2.5e10

-- 布尔值
True
False

-- 字符
'a'
'Z'

-- 字符串
"Hello, World!"

-- 列表
[1, 2, 3, 4, 5]
["apple", "banana", "cherry"]

-- 元组
(1, "hello")
(True, 3.14, 'c')

-- 算术表达式
1 + 2
5 - 3
4 * 2
10 / 3
10 `div` 3  -- 整数除法
10 `mod` 3  -- 取余

-- 布尔表达式
True && False  -- 逻辑与
True || False  -- 逻辑或
not True       -- 逻辑非

-- 比较表达式
1 == 1
1 /= 2
1 < 2
1 <= 1
1 > 2
1 >= 1
</code></pre>
                </div>

                <div class="bg-slate-800 rounded-xl p-6 syntax-card mb-6">
                    <h5 class="text-lg font-medium mb-4 text-green-300">函数定义</h5>
                    <p class="text-slate-300 mb-4">Haskell中的函数定义遵循声明式风格，支持多种定义方式，包括简单函数、递归函数、条件函数、模式匹配函数和守卫表达式等。</p>
                    <pre class="code-block p-4 rounded-lg overflow-x-auto"><code class="code-font text-slate-300">-- 简单函数定义
add :: Int -> Int -> Int
add x y = x + y

-- 递归函数
factorial :: Integer -> Integer
factorial 0 = 1
factorial n = n * factorial (n - 1)

-- 条件函数
absolute :: Int -> Int
absolute x = if x < 0 then -x else x

-- 模式匹配函数
fibonacci :: Int -> Int
fibonacci 0 = 0
fibonacci 1 = 1
fibonacci n = fibonacci (n - 1) + fibonacci (n - 2)

-- 守卫表达式
grade :: Int -> String
grade score
    | score >= 90 = "A"
    | score >= 80 = "B"
    | score >= 70 = "C"
    | score >= 60 = "D"
    | otherwise   = "F"
</code></pre>
                </div>
            </div>
        </section>

        <!-- 3. Haskell 列表操作 -->
        <section id="section-3" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">3. Haskell 列表操作</span>
            </h2>
            
            <div class="language-content" data-lang="haskell">
                <div class="bg-slate-800 rounded-xl p-6 syntax-card mb-6">
                    <h5 class="text-lg font-medium mb-4 text-green-300">列表构造</h5>
                    <p class="text-slate-300 mb-4">Haskell中的列表是一种强大的数据结构，支持多种构造方式，包括空列表、列表构造符、列表范围和无限列表（利用惰性求值特性）。</p>
                    <pre class="code-block p-4 rounded-lg overflow-x-auto"><code class="code-font text-slate-300">-- 空列表
emptyList = []

-- 列表构造符
numbers = 1 : 2 : 3 : []  -- 等价于 [1, 2, 3]

-- 列表范围
oneToFive = [1..5]        -- [1, 2, 3, 4, 5]
evens = [2, 4..10]        -- [2, 4, 6, 8, 10]
countdown = [10, 9..1]     -- [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]

-- 无限列表（惰性求值）
allEvens = [2, 4..]       -- 所有偶数
firstTenEvens = take 10 allEvens  -- [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
</code></pre>
                </div>

                <div class="bg-slate-800 rounded-xl p-6 syntax-card mb-6">
                    <h5 class="text-lg font-medium mb-4 text-green-300">列表推导式</h5>
                    <p class="text-slate-300 mb-4">列表推导式是Haskell中创建和转换列表的强大工具，允许从一个或多个列表中生成新列表，并可以包含条件过滤。</p>
                    <pre class="code-block p-4 rounded-lg overflow-x-auto"><code class="code-font text-slate-300">-- 基本列表推导式
evenNumbers = [x | x <- [1..10], even x]  -- [2, 4, 6, 8, 10]

-- 带多个条件的列表推导式
squaresOfEven = [x*x | x <- [1..10], even x, x > 5]  -- [36, 64, 100]

-- 多重生成器
pairs = [(x, y) | x <- [1..3], y <- ['a'..'c']]  -- [(1,'a'), (1,'b'), (1,'c'), (2,'a'), (2,'b'), (2,'c'), (3,'a'), (3,'b'), (3,'c')]

-- 列表推导式中的函数应用
uppercaseStrings = [map toUpper s | s <- ["hello", "world"]]  -- ["HELLO", "WORLD"]
</code></pre>
                </div>

                <div class="bg-slate-800 rounded-xl p-6 syntax-card mb-6">
                    <h5 class="text-lg font-medium mb-4 text-green-300">内置列表函数</h5>
                    <p class="text-slate-300 mb-4">Haskell提供了丰富的内置列表函数，用于列表的各种操作，如长度计算、排序、映射、过滤和折叠等，这些函数是函数式编程的核心工具。</p>
                    <pre class="code-block p-4 rounded-lg overflow-x-auto"><code class="code-font text-slate-300">-- 列表长度
length [1, 2, 3, 4, 5]  -- 5

-- 列表反转
reverse [1, 2, 3]  -- [3, 2, 1]

-- 列表排序
sort [3, 1, 2]  -- [1, 2, 3]

-- 列表求和
sum [1, 2, 3]  -- 6

-- 列表乘积
product [1, 2, 3, 4]  -- 24

-- 取列表前 n 个元素
take 3 [1, 2, 3, 4, 5]  -- [1, 2, 3]

-- 丢弃列表前 n 个元素
drop 3 [1, 2, 3, 4, 5]  -- [4, 5]

-- 检查元素是否在列表中
elem 3 [1, 2, 3, 4, 5]  -- True

-- 列表映射
map (*2) [1, 2, 3]  -- [2, 4, 6]

-- 列表过滤
filter even [1, 2, 3, 4, 5]  -- [2, 4]

-- 列表折叠（左折叠）
foldl (+) 0 [1, 2, 3, 4]  -- 10

-- 列表折叠（右折叠）
foldr (+) 0 [1, 2, 3, 4]  -- 10
</code></pre>
                </div>
            </div>
        </section>

        <!-- 4. Haskell 函数式编程特性 -->
        <section id="section-4" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">4. Haskell 函数式编程特性</span>
            </h2>
            
            <div class="language-content" data-lang="haskell">
                <div class="bg-slate-800 rounded-xl p-6 syntax-card mb-6">
                    <h5 class="text-lg font-medium mb-4 text-green-300">高阶函数</h5>
                    <p class="text-slate-300 mb-4">高阶函数是函数式编程的核心特性，允许函数作为参数传递给其他函数，或者作为结果返回。这使得代码更加模块化和灵活。</p>
                    <pre class="code-block p-4 rounded-lg overflow-x-auto"><code class="code-font text-slate-300">-- 接收函数作为参数的函数
applyTwice :: (a -> a) -> a -> a
applyTwice f x = f (f x)

-- 使用示例
applyTwice (*2) 3  -- 12
applyTwice (++ "!") "hello"  -- "hello!!"

-- 返回函数的函数
makeAdder :: Int -> (Int -> Int)
makeAdder x = \y -> x + y

-- 使用示例
add5 = makeAdder 5
add5 3  -- 8

-- 柯里化函数
add :: Int -> Int -> Int
add x y = x + y

-- 等价于
add' :: Int -> (Int -> Int)
add' x = \y -> x + y

-- 部分应用
add10 = add 10
add10 5  -- 15
</code></pre>
                </div>

                <div class="bg-slate-800 rounded-xl p-6 syntax-card mb-6">
                    <h5 class="text-lg font-medium mb-4 text-green-300">匿名函数</h5>
                    <p class="text-slate-300 mb-4">匿名函数（Lambda表达式）是没有名称的函数，常用于临时或一次性使用的场景，特别适合作为高阶函数的参数。</p>
                    <pre class="code-block p-4 rounded-lg overflow-x-auto"><code class="code-font text-slate-300">-- 使用匿名函数的 map
map (\x -> x * 2) [1, 2, 3]  -- [2, 4, 6]

-- 使用匿名函数的 filter
filter (\x -> x > 5 && even x) [1..10]  -- [6, 8, 10]

-- 多参数匿名函数
foldr (\x acc -> x : acc) [] [1, 2, 3]  -- [1, 2, 3]
</code></pre>
                </div>

                <div class="bg-slate-800 rounded-xl p-6 syntax-card mb-6">
                    <h5 class="text-lg font-medium mb-4 text-green-300">递归与尾递归</h5>
                    <p class="text-slate-300 mb-4">递归是Haskell中实现循环和迭代的主要方式。尾递归是一种特殊的递归形式，其中递归调用是函数的最后一个操作，允许编译器进行优化，避免栈溢出。</p>
                    <pre class="code-block p-4 rounded-lg overflow-x-auto"><code class="code-font text-slate-300">-- 普通递归
sumList :: [Int] -> Int
sumList [] = 0
sumList (x:xs) = x + sumList xs

-- 尾递归（使用累加器）
sumListTailRec :: [Int] -> Int
sumListTailRec xs = sumHelper xs 0
  where
    sumHelper [] acc = acc
    sumHelper (x:xs) acc = sumHelper xs (x + acc)

-- 快速排序（递归）
quickSort :: Ord a => [a] -> [a]
quickSort [] = []
quickSort (x:xs) = 
  let smallerOrEqual = [y | y <- xs, y <= x]
      larger = [y | y <- xs, y > x]
  in quickSort smallerOrEqual ++ [x] ++ quickSort larger
</code></pre>
                </div>
            </div>
        </section>

        <!-- 5. Haskell 类型系统 -->
        <section id="section-5" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">5. Haskell 类型系统</span>
            </h2>
            
            <div class="language-content" data-lang="haskell">
                <div class="bg-slate-800 rounded-xl p-6 syntax-card mb-6">
                    <h5 class="text-lg font-medium mb-4 text-green-300">类型声明和类型推断</h5>
                    <p class="text-slate-300 mb-4">Haskell具有强大的静态类型系统，支持显式类型声明和类型推断。类型系统确保了程序的类型安全，减少了运行时错误。</p>
                    <pre class="code-block p-4 rounded-lg overflow-x-auto"><code class="code-font text-slate-300">-- 显式类型声明
x :: Int
x = 42

s :: String
s = "Hello"

add :: Int -> Int -> Int
add x y = x + y

-- 多态类型
id :: a -> a
id x = x

const :: a -> b -> a
const x _ = x

length' :: [a] -> Int
length' [] = 0
length' (_:xs) = 1 + length' xs
</code></pre>
                </div>

                <div class="bg-slate-800 rounded-xl p-6 syntax-card mb-6">
                    <h5 class="text-lg font-medium mb-4 text-green-300">代数数据类型</h5>
                    <p class="text-slate-300 mb-4">代数数据类型是Haskell中定义自定义类型的强大方式，支持枚举类型、参数化类型、记录类型和递归类型等多种形式，是函数式编程中数据建模的核心工具。</p>
                    <pre class="code-block p-4 rounded-lg overflow-x-auto"><code class="code-font text-slate-300">-- 简单的代数数据类型
data Bool = True | False

data Maybe a = Nothing | Just a

-- 使用示例
value :: Maybe Int
value = Just 42

emptyValue :: Maybe String
emptyValue = Nothing

-- 记录类型
data Person = Person {
    name :: String,
    age :: Int,
    email :: String
}

-- 使用示例
alice :: Person
alice = Person {
    name = "Alice",
    age = 30,
    email = "alice@example.com"
}

-- 模式匹配使用记录类型
greet :: Person -> String
greet (Person name _ _) = "Hello, " ++ name ++ "!"

-- 递归数据类型
data List a = Nil | Cons a (List a)

data Tree a = Leaf a | Node (Tree a) a (Tree a)

-- 树的遍历
preorder :: Tree a -> [a]
preorder (Leaf x) = [x]
preorder (Node left x right) = [x] ++ preorder left ++ preorder right
</code></pre>
                </div>

                <div class="bg-slate-800 rounded-xl p-6 syntax-card mb-6">
                    <h5 class="text-lg font-medium mb-4 text-green-300">类型类</h5>
                    <p class="text-slate-300 mb-4">类型类是Haskell中实现多态性的核心机制，类似于其他语言中的接口。它定义了一组操作，任何实现了这些操作的类型都可以成为该类型类的实例。</p>
                    <pre class="code-block p-4 rounded-lg overflow-x-auto"><code class="code-font text-slate-300">-- 类型类定义
typeclass Eq a where
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool
    x /= y = not (x == y)

-- 类型类实例
instance Eq Bool where
    True == True = True
    False == False = True
    _ == _ = False

-- 内置类型类示例
-- Eq: 相等性比较
-- Ord: 排序
-- Show: 转换为字符串
-- Read: 从字符串转换
-- Num: 数值类型
-- Integral: 整数类型
-- Fractional: 分数类型

-- 使用类型类约束
max' :: (Ord a) => a -> a -> a
max' x y
    | x > y     = x
    | otherwise = y

-- 多类型类约束
doubleAndShow :: (Num a, Show a) => a -> String
doubleAndShow x = show (x * 2)
</code></pre>
                </div>
            </div>
        </section>

        <!-- 6. Haskell IO 和副作用 -->
        <section id="section-6" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">6. Haskell IO 和副作用</span>
            </h2>
            
            <div class="language-content" data-lang="haskell">
                <div class="bg-slate-800 rounded-xl p-6 syntax-card mb-6">
                    <h5 class="text-lg font-medium mb-4 text-green-300">基本 IO 操作</h5>
                    <p class="text-slate-300 mb-4">IO操作是Haskell中处理副作用的方式，包括输入输出、文件操作等。IO操作被组织成Monad链，确保了副作用的可控性。</p>
                    <pre class="code-block p-4 rounded-lg overflow-x-auto"><code class="code-font text-slate-300">-- 输出
main :: IO ()
main = do
    putStrLn "Hello, Haskell!"
    putStr "Enter your name: "
    
    -- 输入
    name <- getLine
    
    -- 格式化输出
    putStrLn $ "Nice to meet you, " ++ name ++ "!"

-- IO 组合
readAndDouble :: IO ()
readAndDouble = do
    putStr "Enter a number: "
    input <- getLine
    let number = read input :: Int
    putStrLn $ "Double of " ++ show number ++ " is " ++ show (number * 2)

-- 纯函数与 IO 结合
calculateSum :: [Int] -> Int
calculateSum = sum

printSum :: IO ()
printSum = do
    let numbers = [1, 2, 3, 4, 5]
        total = calculateSum numbers
    putStrLn $ "Sum of " ++ show numbers ++ " is " ++ show total
</code></pre>
                </div>

                <div class="bg-slate-800 rounded-xl p-6 syntax-card mb-6">
                    <h5 class="text-lg font-medium mb-4 text-green-300">Monad 简介</h5>
                    <p class="text-slate-300 mb-4">Monad是Haskell中用于处理副作用、顺序计算和上下文传递的核心抽象。它提供了一种结构化的方式来组合计算，同时保持代码的清晰和类型安全。</p>
                    <pre class="code-block p-4 rounded-lg overflow-x-auto"><code class="code-font text-slate-300">-- Maybe Monad 示例
safeDivide :: Double -> Double -> Maybe Double
safeDivide _ 0 = Nothing
safeDivide x y = Just (x / y)

-- 使用 Maybe Monad 链式操作
result :: Maybe Double
result = do
    x <- safeDivide 10 2
    y <- safeDivide 20 4
    safeDivide x y  -- Just 1.25

-- 使用绑定操作符 (>>=)
result' :: Maybe Double
result' = safeDivide 10 2 >>= \x ->
          safeDivide 20 4 >>= \y ->
          safeDivide x y

-- IO Monad 是 Haskell 处理副作用的方式
-- IO 操作被组织成一个 Monad 链
-- 每个 IO 操作都返回一个包含结果的 IO 动作
main :: IO ()
main = do
    putStrLn "Enter first number:"
    num1 <- getLine
    putStrLn "Enter second number:"
    num2 <- getLine
    let result = read num1 + read num2
    putStrLn $ "Sum: " ++ show result
</code></pre>
                </div>

                <div class="bg-slate-800 rounded-xl p-6 syntax-card mb-6">
                    <h5 class="text-lg font-medium mb-4 text-green-300">模块系统</h5>
                    <p class="text-slate-300 mb-4">Haskell的模块系统用于组织和复用代码，通过module和import语句可以创建和使用模块。</p>
                    <pre class="code-block p-4 rounded-lg overflow-x-auto"><code class="code-font text-slate-300">-- 模块定义（MyModule.hs）
module MyModule (add, multiply) where  -- 导出函数

add :: Int -> Int -> Int
add x y = x + y

multiply :: Int -> Int -> Int
multiply x y = x * y

-- 内部函数（不导出）
subtract :: Int -> Int -> Int
subtract x y = x - y

-- 模块导入
-- import MyModule  -- 导入所有导出函数
-- import MyModule (add)  -- 只导入add函数
-- import MyModule hiding (multiply)  -- 导入除multiply外的所有函数
-- import qualified MyModule as MM  -- 导入并使用别名
-- import qualified MyModule as MM (add)  -- 带别名的选择性导入
</code></pre>
                </div>

                <div class="bg-slate-800 rounded-xl p-6 syntax-card mb-6">
                    <h5 class="text-lg font-medium mb-4 text-green-300">类型别名</h5>
                    <p class="text-slate-300 mb-4">类型别名使用type关键字定义，用于为现有类型创建更具描述性的名称，提高代码可读性。</p>
                    <pre class="code-block p-4 rounded-lg overflow-x-auto"><code class="code-font text-slate-300">-- 基本类型别名
type Name = String
type Age = Int
type Email = String

-- 带参数的类型别名
type Pair a = (a, a)
type Triplet a b c = (a, b, c)

type PersonInfo = (Name, Age, Email)

-- 使用类型别名
greet :: Name -> String
greet name = "Hello, " ++ name ++ "!"

createPerson :: Name -> Age -> Email -> PersonInfo
createPerson name age email = (name, age, email)

-- 类型别名与记录类型
data Person = Person {
    personName :: Name,
    personAge :: Age,
    personEmail :: Email
}
</code></pre>
                </div>

                <div class="bg-slate-800 rounded-xl p-6 syntax-card mb-6">
                    <h5 class="text-lg font-medium mb-4 text-green-300">Either Monad</h5>
                    <p class="text-slate-300 mb-4">Either Monad类似于Maybe，但可以携带错误信息，常用于错误处理，其中Left表示错误，Right表示成功。</p>
                    <pre class="code-block p-4 rounded-lg overflow-x-auto"><code class="code-font text-slate-300">-- Either类型定义
data Either a b = Left a | Right b

-- 使用Either进行错误处理
safeDivide :: Double -> Double -> Either String Double
safeDivide _ 0 = Left "Division by zero"
safeDivide x y = Right (x / y)

-- 使用Either Monad链式操作
result :: Either String Double
result = do
    x <- safeDivide 10 2
    y <- safeDivide 20 4
    z <- safeDivide x 0  -- 这里会产生错误
    Right (x * y * z)

-- 使用绑定操作符 (>>=)
result' :: Either String Double
result' = safeDivide 10 2 >>= \
          \x -> safeDivide 20 4 >>= \
          \y -> safeDivide x y >>= \
          \z -> Right (x * y * z)

-- 处理Either结果
processResult :: Either String Double -> String
processResult (Left errorMsg) = "Error: " ++ errorMsg
processResult (Right value) = "Result: " ++ show value
</code></pre>
                </div>

                <div class="bg-slate-800 rounded-xl p-6 syntax-card mb-6">
                    <h5 class="text-lg font-medium mb-4 text-green-300">List Monad</h5>
                    <p class="text-slate-300 mb-4">List Monad用于非确定性计算，允许一个值映射到多个可能的结果。</p>
                    <pre class="code-block p-4 rounded-lg overflow-x-auto"><code class="code-font text-slate-300">-- 使用List Monad进行非确定性计算
possibleResults :: [(Int, Int, Int)]
possibleResults = do
    x <- [1, 2, 3]
    y <- [4, 5]
    z <- [6]
    if x + y + z > 10 then return (x, y, z) else []

-- 等价于
possibleResults' :: [(Int, Int, Int)]
possibleResults' = 
    [1, 2, 3] >>= \
    \x -> [4, 5] >>= \
    \y -> [6] >>= \
    \z -> if x + y + z > 10 then [(x, y, z)] else []

-- 列表推导式与List Monad等价
possibleResults'' :: [(Int, Int, Int)]
possibleResults'' = [(x, y, z) | x <- [1, 2, 3], y <- [4, 5], z <- [6], x + y + z > 10]
</code></pre>
                </div>

                <div class="bg-slate-800 rounded-xl p-6 syntax-card mb-6">
                    <h5 class="text-lg font-medium mb-4 text-green-300">Let和Where表达式</h5>
                    <p class="text-slate-300 mb-4">Let和Where表达式用于在本地范围内定义变量和函数，提高代码可读性和复用性。</p>
                    <pre class="code-block p-4 rounded-lg overflow-x-auto"><code class="code-font text-slate-300">-- Let表达式（在表达式内部定义）
circleArea :: Double -> Double
circleArea radius = 
    let pi = 3.14159
        area = pi * radius * radius
    in area

-- Where表达式（在函数定义末尾定义）
rectangleArea :: Double -> Double -> Double
rectangleArea width height = width * height
    where
        perimeter = 2 * (width + height)
        diagonal = sqrt (width * width + height * height)

-- 在条件表达式中使用Let
grade :: Int -> String
grade score = 
    let 
        excellent = 90
        good = 80
        average = 70
        passing = 60
    in
        if score >= excellent then "A"
        else if score >= good then "B"
        else if score >= average then "C"
        else if score >= passing then "D"
        else "F"

-- 在do notation中使用Let
main :: IO ()
main = do
    putStrLn "Enter two numbers:"
    num1Str <- getLine
    num2Str <- getLine
    let 
        num1 = read num1Str :: Int
        num2 = read num2Str :: Int
        sum = num1 + num2
    putStrLn $ "Sum: " ++ show sum
</code></pre>
                </div>

                <div class="bg-slate-800 rounded-xl p-6 syntax-card mb-6">
                    <h5 class="text-lg font-medium mb-4 text-green-300">异常处理</h5>
                    <p class="text-slate-300 mb-4">Haskell支持传统的异常处理机制，通过Control.Exception模块提供。</p>
                    <pre class="code-block p-4 rounded-lg overflow-x-auto"><code class="code-font text-slate-300">-- 导入异常处理模块
-- import Control.Exception

-- 抛出异常
throwExample :: Int -> Int
throwExample x = 
    if x == 0 then error "Division by zero" 
    else 10 `div` x

-- 捕获异常
catchExample :: Int -> String
catchExample x = 
    catch
        (show (throwExample x))
        (\e -> "Caught exception: " ++ show (e :: SomeException))

-- 资源管理（bracket）
-- bracketExample :: IO ()
-- bracketExample = 
--     bracket
--         (openFile "test.txt" ReadMode)  -- 获取资源
--         hClose                           -- 释放资源
--         (\handle -> do                   -- 使用资源
--             content <- hGetContents handle
--             putStrLn content)
</code></pre>
                </div>
            </div>
        </section>
            </div>
        </div>
    </main>
</body>
</html>