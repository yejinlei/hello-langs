<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C++ 语言教程</title>
    <script>
        // 尝试加载 Tailwind CSS，如果失败则使用备用方案
        window.tailwindCdnLoaded = false;
        function loadTailwindCSS() {
            const script = document.createElement('script');
            script.src = 'https://cdn.tailwindcss.com';
            script.onload = function() {
                window.tailwindCdnLoaded = true;
                // Tailwind 配置
                tailwind.config = {
                    theme: {
                        extend: {
                            colors: {
                                primary: '#10b981',
                                secondary: '#8b5cf6',
                                dark: '#1e293b',
                                light: '#f8fafc'
                            }
                        }
                    }
                }
            };
            script.onerror = function() {
                console.warn('Failed to load Tailwind CSS from CDN, applying fallback styles');
                applyFallbackStyles();
            };
            document.head.appendChild(script);
        }
        
        function applyFallbackStyles() {
            // 应用基本的 Tailwind 类对应的样式
            const fallbackStyles = document.createElement('style');
            fallbackStyles.textContent = `
                /* 基本布局类 */
                .container { width: 100%; margin-right: auto; margin-left: auto; padding-right: 1rem; padding-left: 1rem; }
                .grid { display: grid; }
                .flex { display: flex; }
                .hidden { display: none; }
                
                /* 网格列类 */
                .grid-cols-1 { grid-template-columns: repeat(1, minmax(0, 1fr)); }
                @media (min-width: 1024px) {
                    .lg\\:grid-cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
                }
                
                /* 间距类 */
                .p-8 { padding: 2rem; }
                .p-4 { padding: 1rem; }
                .mb-16 { margin-bottom: 4rem; }
                .mb-8 { margin-bottom: 2rem; }
                .mb-4 { margin-bottom: 1rem; }
                .mb-2 { margin-bottom: 0.5rem; }
                .mt-4 { margin-top: 1rem; }
                .mr-2 { margin-right: 0.5rem; }
                .ml-2 { margin-left: 0.5rem; }
                
                /* 字体类 */
                .text-3xl { font-size: 1.875rem; }
                .text-lg { font-size: 1.125rem; }
                .text-sm { font-size: 0.875rem; }
                .font-bold { font-weight: 700; }
                .font-medium { font-weight: 500; }
                
                /* 文本类 */
                .text-center { text-align: center; }
                .text-purple-400 { color: #a78bfa; }
                .text-slate-300 { color: #cbd5e1; }
                .text-slate-400 { color: #94a3b8; }
                
                /* 背景类 */
                .bg-slate-900 { background-color: #0f172a; }
                .bg-slate-800 { background-color: #1e293b; }
                
                /* 边框类 */
                .rounded-xl { border-radius: 0.75rem; }
                .rounded-lg { border-radius: 0.5rem; }
                .rounded { border-radius: 0.25rem; }
                
                /* 其他类 */
                .gap-8 { gap: 2rem; }
                .items-center { align-items: center; }
                .justify-between { justify-content: space-between; }
                .w-full { width: 100%; }
            `;
            document.head.appendChild(fallbackStyles);
        }
        
        // 加载 Tailwind CSS
        loadTailwindCSS();
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700&family=JetBrains+Mono:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        * {
            font-family: 'Noto Sans SC', sans-serif;
        }
        .gradient-text {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            color: transparent;
        }
        
        .code-font {
            font-family: 'JetBrains Mono', monospace;
        }
        
        .syntax-card {
            background: linear-gradient(145deg, rgba(30, 41, 59, 0.8), rgba(15, 23, 42, 0.9));
            backdrop-filter: blur(10px);
            border: 1px solid rgba(148, 163, 184, 0.1);
        }
        
        .language-tab {
            transition: all 0.3s ease;
        }
        
        .language-tab.active {
            background: linear-gradient(135deg, #3B82F6, #8B5CF6);
            color: white;
        }
        
        .code-block {
            background: rgba(2, 6, 23, 0.9);
            border-left: 4px solid #3B82F6;
        }
        
        .highlight {
            background: rgba(59, 130, 246, 0.2);
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        .language-content.hidden {
            display: none;
        }
        
        body {
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
        }
    </style>
</head>
<body class="min-h-screen">
    <main class="container mx-auto px-4 py-8 max-w-6xl">
          <div class="flex flex-col lg:flex-row gap-8">
              <nav class="lg:w-1/4 bg-slate-800 rounded-xl p-6 h-fit">
                      <h3 class="text-lg font-bold text-purple-400 mb-4">章节导航</h3>
                      <div class="space-y-2">
                          <a href="#section-1" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">1. 变量声明与初始化</a>
                          <a href="#section-2" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">2. 基本数据类型</a>
                          <a href="#section-3" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">3. 控制流语句</a>
                          <a href="#section-4" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">4. 函数定义</a>
                          <a href="#section-5" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">5. 数组与容器</a>
                          <a href="#section-6" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">6. 指针与引用</a>
                          <a href="#section-7" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">7. 类与对象</a>
                          <a href="#section-8" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">8. 继承与多态</a>
                          <a href="#section-9" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">9. 模板</a>
                          <a href="#section-10" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">10. 异常处理</a>
                          <a href="#section-11" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">11. 面向对象编程</a>
                          <a href="#section-12" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">12. 继承和多态</a>
                          <a href="#section-13" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">13. 异常处理</a>
                          <a href="#section-14" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">14. 智能指针</a>
                          <a href="#section-15" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">15. 文件操作</a>
                          <a href="#section-16" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">16. Lambda表达式</a>
                          <a href="#section-17" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">17. 移动语义</a>
                          <a href="#section-18" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">18. 基于范围的for循环</a>
                          <a href="#section-19" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">19. nullptr关键字</a>
                          <a href="#section-20" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">20. 强类型枚举</a>
                          <a href="#section-21" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">21. 可变参数模板</a>
                          <a href="#section-22" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">22. 线程库</a>
                          <a href="#section-23" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">23. 正则表达式库</a>
                          <a href="#section-24" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">24. <span class="text-green-300">std::function</span>和std::bind</a>
                          <a href="#section-25" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">25. 新的字符串字面量</a>
                          <a href="#section-26" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">26. 委托构造函数和继承构造函数</a>
                          <a href="#section-27" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">27. final/override控制</a>
                          <a href="#section-28" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">28. 原子操作</a>
                          <a href="#section-29" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">29. chrono时间库</a>
                          <a href="#section-30" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">30. 随机数库</a>
                          <a href="#section-31" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">31. 新的算法和容器</a>
                      </div>
              </nav>
              <div class="lg:w-3/4">
                  <!-- 1. 变量声明与初始化 -->
                  <section id="section-1" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">1. 变量声明与初始化</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 变量声明、初始化和类型推导</h4>
                <p class="text-slate-300 mb-4">特点：支持多种数据类型，支持自动类型推导(auto)，支持统一初始化语法。注意事项：C++11引入了统一初始化语法，避免窄化转换，提高安全性。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 基本变量声明</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 传统声明</span><br>
                        <span class="text-purple-400">int</span> age = <span class="text-yellow-300">25</span>;<br>
                        <span class="text-purple-400">double</span> price = <span class="text-yellow-300">19.99</span>;<br>
                        <span class="text-purple-400">char</span> grade = <span class="text-green-300">'A'</span>;<br>
                        <span class="text-purple-400">bool</span> isActive = <span class="text-green-300">true</span>;<br>
                        <br>
                        <span class="text-blue-300">// C++11 统一初始化语法</span><br>
                        <span class="text-purple-400">int</span> x{<span class="text-yellow-300">10</span>};<br>
                        <span class="text-purple-400">double</span> y{<span class="text-yellow-300">3.14</span>};<br>
                        <span class="text-purple-400">std::string</span> name{<span class="text-green-300">"Hello"</span>};<br>
                        <br>
                        <span class="text-blue-300">// 类型推导</span><br>
                        <span class="text-purple-400">auto</span> num = <span class="text-yellow-300">42</span>; <span class="text-blue-300">// 推导为 int</span><br>
                        <span class="text-purple-400">auto</span> pi = <span class="text-yellow-300">3.14159</span>; <span class="text-blue-300">// 推导为 double</span><br>
                        <span class="text-purple-400">auto</span> flag = <span class="text-green-300">false</span>; <span class="text-blue-300">// 推导为 bool</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- 2. 基本数据类型 -->
        <section id="section-2" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">2. 基本数据类型</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 基本数据类型和大小</h4>
                <p class="text-slate-300 mb-4">特点：包括整型、浮点型、字符型、布尔型等，C++11引入了long long等扩展类型。注意事项：不同类型占用内存大小可能因平台而异，使用sizeof运算符可获取类型大小。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 基本数据类型</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 整型</span><br>
                        <span class="text-purple-400">bool</span> b = <span class="text-green-300">true</span>; <span class="text-blue-300">// 1 字节</span><br>
                        <span class="text-purple-400">char</span> c = <span class="text-green-300">'A'</span>; <span class="text-blue-300">// 1 字节</span><br>
                        <span class="text-purple-400">int</span> i = <span class="text-yellow-300">42</span>; <span class="text-blue-300">// 通常 4 字节</span><br>
                        <span class="text-purple-400">long</span> l = <span class="text-yellow-300">1000000L</span>; <span class="text-blue-300">// 通常 4 或 8 字节</span><br>
                        <span class="text-purple-400">long</span> <span class="text-purple-400">long</span> ll = <span class="text-yellow-300">10000000000LL</span>; <span class="text-blue-300">// 8 字节 (C++11)</span><br>
                        <br>
                        <span class="text-blue-300">// 浮点型</span><br>
                        <span class="text-purple-400">float</span> f = <span class="text-yellow-300">3.14f</span>; <span class="text-blue-300">// 4 字节</span><br>
                        <span class="text-purple-400">double</span> d = <span class="text-yellow-300">3.14159</span>; <span class="text-blue-300">// 8 字节</span><br>
                        <span class="text-purple-400">long</span> <span class="text-purple-400">double</span> ld = <span class="text-yellow-300">3.141592653589793L</span>; <span class="text-blue-300">// 通常 10 或 16 字节</span><br>
                        <br>
                        <span class="text-blue-300">// 类型大小</span><br>
                        <span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"sizeof(int): "</span> &lt;&lt; <span class="text-purple-400">sizeof</span>(<span class="text-purple-400">int</span>) &lt;&lt; <span class="text-green-300">std::endl</span>;
                    </div>
                </div>
            </div>
        </section>

        <!-- 3. 控制流语句 -->
        <section id="section-3" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">3. 控制流语句</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 条件语句、循环语句和范围for循环</h4>
                <p class="text-slate-300 mb-4">特点：支持if/else、switch、for、while、do-while等传统控制流，C++11新增范围for循环。注意事项：使用范围for循环遍历容器更安全便捷，避免越界问题。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 控制流语句</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// if-else 语句</span><br>
                        <span class="text-purple-400">int</span> score = <span class="text-yellow-300">85</span>;<br>
                        <span class="text-purple-400">if</span> (score &gt;= <span class="text-yellow-300">90</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"优秀"</span> &lt;&lt; <span class="text-green-300">std::endl</span>;<br>
                        } <span class="text-purple-400">else</span> <span class="text-purple-400">if</span> (score &gt;= <span class="text-yellow-300">80</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"良好"</span> &lt;&lt; <span class="text-green-300">std::endl</span>;<br>
                        } <span class="text-purple-400">else</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"需努力"</span> &lt;&lt; <span class="text-green-300">std::endl</span>;<br>
                        }<br>
                        <br>
                        <span class="text-blue-300">// 范围 for 循环 (C++11)</span><br>
                        <span class="text-purple-400">std::vector</span>&lt;<span class="text-purple-400">int</span>&gt; numbers = {<span class="text-yellow-300">1</span>, <span class="text-yellow-300">2</span>, <span class="text-yellow-300">3</span>, <span class="text-yellow-300">4</span>, <span class="text-yellow-300">5</span>};<br>
                        <span class="text-purple-400">for</span> (<span class="text-purple-400">const</span> <span class="text-purple-400">auto</span>& element : numbers) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-green-300">std::cout</span> &lt;&lt; element &lt;&lt; <span class="text-green-300">" "</span>;<br>
                        }<br>
                        <span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">std::endl</span>;
                    </div>
                </div>
            </div>
        </section>

        <!-- 4. 函数定义 -->
        <section id="section-4" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">4. 函数定义</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 函数定义、默认参数、函数重载和Lambda表达式</h4>
                <p class="text-slate-300 mb-4">特点：支持函数重载、默认参数、Lambda表达式等特性。注意事项：C++11引入了Lambda表达式，提供了更灵活的函数式编程能力。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 函数定义</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 基本函数定义</span><br>
                        <span class="text-purple-400">int</span> <span class="text-blue-300">add</span>(<span class="text-purple-400">int</span> a, <span class="text-purple-400">int</span> b) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> a + b;<br>
                        }<br>
                        <br>
                        <span class="text-blue-300">// 带默认参数的函数</span><br>
                        <span class="text-purple-400">double</span> <span class="text-blue-300">calculateArea</span>(<span class="text-purple-400">double</span> radius, <span class="text-purple-400">double</span> pi = <span class="text-yellow-300">3.14159</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> pi * radius * radius;<br>
                        }<br>
                        <br>
                        <span class="text-blue-300">// 函数重载</span><br>
                        <span class="text-purple-400">int</span> <span class="text-blue-300">max</span>(<span class="text-purple-400">int</span> a, <span class="text-purple-400">int</span> b) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> (a &gt; b) ? a : b;<br>
                        }<br>
                        <span class="text-purple-400">double</span> <span class="text-blue-300">max</span>(<span class="text-purple-400">double</span> a, <span class="text-purple-400">double</span> b) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> (a &gt; b) ? a : b;<br>
                        }<br>
                        <br>
                        <span class="text-blue-300">// Lambda 表达式 (C++11)</span><br>
                        <span class="text-purple-400">auto</span> multiply = [](<span class="text-purple-400">int</span> x, <span class="text-purple-400">int</span> y) { <span class="text-purple-400">return</span> x * y; };<br>
                        <span class="text-purple-400">int</span> result = <span class="text-blue-300">multiply</span>(<span class="text-yellow-300">5</span>, <span class="text-yellow-300">3</span>); <span class="text-blue-300">// 结果为 15</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- 5. 数组与容器 -->
        <section id="section-5" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">5. 数组与容器</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 传统数组、std::array和STL容器</h4>
                <p class="text-slate-300 mb-4">特点：支持传统C风格数组，C++11引入了std::array，STL提供了丰富的容器。注意事项：推荐使用STL容器，它们更安全且功能更强大。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 数组与容器</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 传统数组</span><br>
                        <span class="text-purple-400">int</span> arr[<span class="text-yellow-300">5</span>] = {<span class="text-yellow-300">1</span>, <span class="text-yellow-300">2</span>, <span class="text-yellow-300">3</span>, <span class="text-yellow-300">4</span>, <span class="text-yellow-300">5</span>};<br>
                        <br>
                        <span class="text-blue-300">// std::array (C++11)</span><br>
                        <span class="text-purple-400">std::array</span>&lt;<span class="text-purple-400">int</span>, <span class="text-yellow-300">5</span>&gt; cppArray = {<span class="text-yellow-300">1</span>, <span class="text-yellow-300">2</span>, <span class="text-yellow-300">3</span>, <span class="text-yellow-300">4</span>, <span class="text-yellow-300">5</span>};<br>
                        <br>
                        <span class="text-blue-300">// std::vector</span><br>
                        <span class="text-purple-400">std::vector</span>&lt;<span class="text-purple-400">int</span>&gt; vec = {1, 2, 3, 4, 5};<br>
                        <br>
                        <span class="text-blue-300">// std::map - 关联容器</span><br>
                        <span class="text-purple-400">std::map</span>&lt;<span class="text-purple-400">std::string</span>, <span class="text-purple-400">int</span>&gt; studentScores;<br>
                        studentScores[<span class="text-green-300">"Alice"</span>] = <span class="text-yellow-300">95</span>;<br>
                        studentScores[<span class="text-green-300">"Bob"</span>] = <span class="text-yellow-300">88</span>;<br>
                        <br>
                        <span class="text-blue-300">// std::set - 集合容器</span><br>
                        <span class="text-purple-400">std::set</span>&lt;<span class="text-purple-400">int</span>&gt; uniqueNumbers = {<span class="text-yellow-300">1</span>, <span class="text-yellow-300">2</span>, <span class="text-yellow-300">2</span>, <span class="text-yellow-300">3</span>, <span class="text-yellow-300">4</span>};<br>
                    </div>
                </div>
            </div>
        </section>

        <!-- 6. 指针与引用 -->
        <section id="section-6" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">6. 指针与引用</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 指针、引用和智能指针</h4>
                <p class="text-slate-300 mb-4">特点：支持传统指针和引用，C++11引入了智能指针管理内存。注意事项：优先使用智能指针，避免内存泄漏和悬空指针问题。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 指针与引用</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 指针</span><br>
                        <span class="text-purple-400">int</span> value = <span class="text-yellow-300">42</span>;<br>
                        <span class="text-purple-400">int</span>* ptr = &amp;value; <span class="text-blue-300">// 指向value的指针</span><br>
                        <span class="text-purple-400">int</span> dereferenced = *ptr; <span class="text-blue-300">// 解引用</span><br>
                        <br>
                        <span class="text-blue-300">// 引用</span><br>
                        <span class="text-purple-400">int</span>&amp; ref = value; <span class="text-blue-300">// value的引用</span><br>
                        ref = <span class="text-yellow-300">100</span>; <span class="text-blue-300">// value现在是100</span><br>
                        <br>
                        <span class="text-blue-300">// 智能指针 (C++11)</span><br>
                        <span class="text-purple-400">std::unique_ptr</span>&lt;<span class="text-purple-400">int</span>&gt; uniquePtr = <span class="text-blue-300">std::make_unique</span>&lt;<span class="text-purple-400">int</span>&gt;(<span class="text-yellow-300">42</span>);<br>
                        <span class="text-purple-400">std::shared_ptr</span>&lt;<span class="text-purple-400">int</span>&gt; sharedPtr1 = <span class="text-blue-300">std::make_shared</span>&lt;<span class="text-purple-400">int</span>&gt;(<span class="text-yellow-300">42</span>);<br>
                        <span class="text-purple-400">std::shared_ptr</span>&lt;<span class="text-purple-400">int</span>&gt; sharedPtr2 = sharedPtr1; <span class="text-blue-300">// 引用计数增加</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- 7. 类与对象 -->
        <section id="section-7" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">7. 类与对象</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 类定义、构造函数和析构函数</h4>
                <p class="text-slate-300 mb-4">特点：支持封装、继承、多态等面向对象特性，C++11引入了默认函数、删除函数等。注意事项：合理使用构造函数和析构函数管理资源，遵循RAII原则。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 类与对象</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 类定义</span><br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">Person</span> {<br>
                        <span class="text-purple-400">private</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">std::string</span> name;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">int</span> age;<br>
                        <br>
                        <span class="text-purple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">Person</span>(<span class="text-purple-400">const</span> <span class="text-purple-400">std::string</span>& n, <span class="text-purple-400">int</span> a) : name(n), age(a) {} <span class="text-blue-300">// 构造函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">~Person</span>() { <span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"Person destroyed"</span> &lt;&lt; <span class="text-green-300">std::endl</span>; } <span class="text-blue-300">// 析构函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">const</span> <span class="text-purple-400">std::string</span>& <span class="text-blue-300">getName</span>() <span class="text-purple-400">const</span> { <span class="text-purple-400">return</span> name; }<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">int</span> <span class="text-blue-300">getAge</span>() <span class="text-purple-400">const</span> { <span class="text-purple-400">return</span> age; }<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">void</span> <span class="text-blue-300">setAge</span>(<span class="text-purple-400">int</span> newAge) { age = newAge; }<br>
                        };<br>
                        <br>
                        <span class="text-blue-300">// 对象创建和使用</span><br>
                        <span class="text-blue-300">Person</span> person(<span class="text-green-300">"Alice"</span>, <span class="text-yellow-300">30</span>);<br>
                        <span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"Name: "</span> &lt;&lt; person.<span class="text-blue-300">getName</span>() &lt;&lt; <span class="text-green-300">", Age: "</span> &lt;&lt; person.<span class="text-blue-300">getAge</span>() &lt;&lt; <span class="text-green-300">std::endl</span>;
                    </div>
                </div>
            </div>
        </section>

        <!-- 8. 继承与多态 -->
        <section id="section-8" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">8. 继承与多态</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 继承、虚函数和多态</h4>
                <p class="text-slate-300 mb-4">特点：支持单继承和多继承，虚函数实现动态多态，C++11引入了override和final关键字。注意事项：使用override关键字确保函数重写，合理设计继承层次结构。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 继承与多态</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 基类</span><br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">Animal</span> {
                        <span class="text-purple-400">protected</span>:
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">std::string</span> name;
                        <br>
                        <span class="text-purple-400">public</span>:
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">Animal</span>(<span class="text-purple-400">const</span> <span class="text-purple-400">std::string</span>& n) : name(n) {}
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">virtual</span> <span class="text-blue-300">~Animal</span>() = <span class="text-purple-400">default</span>; <span class="text-blue-300">// 虚析构函数</span>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">virtual</span> <span class="text-purple-400">void</span> <span class="text-blue-300">speak</span>() <span class="text-purple-400">const</span> { <span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"Animal speaks"</span> &lt;&lt; <span class="text-green-300">std::endl</span>; }
                        };
                        <br>
                        <span class="text-blue-300">// 派生类</span><br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">Dog</span> : <span class="text-purple-400">public</span> <span class="text-blue-300">Animal</span> {
                        <span class="text-purple-400">public</span>:
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">Dog</span>(<span class="text-purple-400">const</span> <span class="text-purple-400">std::string</span>& n) : <span class="text-blue-300">Animal</span>(n) {}
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">void</span> <span class="text-blue-300">speak</span>() <span class="text-purple-400">const</span> <span class="text-purple-400">override</span> { <span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"Woof!"</span> &lt;&lt; <span class="text-green-300">std::endl</span>; } <span class="text-blue-300">// C++11 override</span>
                        };
                        <br>
                        <span class="text-blue-300">// 多态使用</span><br>
                        <span class="text-blue-300">Animal</span>* animal = <span class="text-purple-400">new</span> <span class="text-blue-300">Dog</span>(<span class="text-green-300">"Buddy"</span>);
                        animal-&gt;<span class="text-blue-300">speak</span>(); <span class="text-blue-300">// 输出 "Woof!"</span>
                        <span class="text-purple-400">delete</span> animal;
                    </div>
                </div>
            </div>
        </section>

        <!-- 9. 模板 -->
        <section id="section-9" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">9. 模板</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 函数模板和类模板</h4>
                <p class="text-slate-300 mb-4">特点：支持函数模板和类模板，实现泛型编程，C++11引入了可变参数模板。注意事项：模板在编译时生成代码，可能增加编译时间和可执行文件大小。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 模板</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 函数模板</span><br>
                        <span class="text-purple-400">template</span>&lt;<span class="text-purple-400">typename</span> T&gt;
                        T <span class="text-blue-300">max</span>(T a, T b) {
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> (a &gt; b) ? a : b;
                        }
                        <br>
                        <span class="text-blue-300">// 使用函数模板</span><br>
                        <span class="text-purple-400">int</span> intMax = <span class="text-blue-300">max</span>(<span class="text-yellow-300">10</span>, <span class="text-yellow-300">20</span>);
                        <span class="text-purple-400">double</span> doubleMax = <span class="text-blue-300">max</span>(<span class="text-yellow-300">3.14</span>, <span class="text-yellow-300">2.71</span>);
                        <br>
                        <span class="text-blue-300">// 类模板</span><br>
                        <span class="text-purple-400">template</span>&lt;<span class="text-purple-400">typename</span> T&gt;
                        <span class="text-purple-400">class</span> <span class="text-blue-300">Container</span> {
                        <span class="text-purple-400">private</span>:
                        &nbsp;&nbsp;&nbsp;&nbsp;T value;
                        <br>
                        <span class="text-purple-400">public</span>:
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">Container</span>(T v) : value(v) {}
                        &nbsp;&nbsp;&nbsp;&nbsp;T <span class="text-blue-300">getValue</span>() <span class="text-purple-400">const</span> { <span class="text-purple-400">return</span> value; }
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">void</span> <span class="text-blue-300">setValue</span>(T v) { value = v; }
                        };
                    </div>
                </div>
            </div>
        </section>

        <!-- 10. 异常处理 -->
        <section id="section-10" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">10. 异常处理</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 异常处理机制</h4>
                <p class="text-slate-300 mb-4">特点：支持try-catch-finally模式，可以抛出任意类型的异常，C++11增强了异常安全性。注意事项：异常处理会影响性能，不应作为常规流程控制使用。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 异常处理</div>
                    <div class="text-sm leading-6">
                        <span class="text-purple-400">try</span> {
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">std::vector</span>&lt;<span class="text-purple-400">int</span>&gt; vec(<span class="text-yellow-300">5</span>);
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-green-300">std::cout</span> &lt;&lt; vec.<span class="text-blue-300">at</span>(<span class="text-yellow-300">10</span>) &lt;&lt; <span class="text-green-300">std::endl</span>; <span class="text-blue-300">// 抛出 std::out_of_range</span>
                        } <span class="text-purple-400">catch</span> (<span class="text-purple-400">const</span> <span class="text-blue-300">std::out_of_range</span>& e) {
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"Out of range error: "</span> &lt;&lt; e.<span class="text-blue-300">what</span>() &lt;&lt; <span class="text-green-300">std::endl</span>;
                        } <span class="text-purple-400">catch</span> (...) {
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"Unknown exception"</span> &lt;&lt; <span class="text-green-300">std::endl</span>;
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 11. 面向对象编程 -->
        <section id="section-11" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">11. 面向对象编程</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 面向对象编程特性</h4>
                <p class="text-slate-300 mb-4">特点：封装、继承、多态三大特性，支持抽象类和接口设计。注意事项：合理使用访问控制符，遵循面向对象设计原则。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 面向对象编程</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 抽象类</span><br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">Shape</span> {
                        <span class="text-purple-400">public</span>:
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">virtual</span> <span class="text-purple-400">double</span> <span class="text-blue-300">area</span>() <span class="text-purple-400">const</span> = <span class="text-yellow-300">0</span>; <span class="text-blue-300">// 纯虚函数</span>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">virtual</span> <span class="text-purple-400">void</span> <span class="text-blue-300">draw</span>() <span class="text-purple-400">const</span> = <span class="text-yellow-300">0</span>; <span class="text-blue-300">// 纯虚函数</span>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">virtual</span> <span class="text-blue-300">~Shape</span>() = <span class="text-purple-400">default</span>;
                        };
                        <br>
                        <span class="text-blue-300">// 具体实现类</span><br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">Circle</span> : <span class="text-purple-400">public</span> <span class="text-blue-300">Shape</span> {
                        <span class="text-purple-400">private</span>:
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">double</span> radius;
                        <br>
                        <span class="text-purple-400">public</span>:
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">Circle</span>(<span class="text-purple-400">double</span> r) : radius(r) {}
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">double</span> <span class="text-blue-300">area</span>() <span class="text-purple-400">const</span> <span class="text-purple-400">override</span> { <span class="text-purple-400">return</span> <span class="text-yellow-300">3.14159</span> * radius * radius; }
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">void</span> <span class="text-blue-300">draw</span>() <span class="text-purple-400">const</span> <span class="text-purple-400">override</span> { <span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"Drawing a circle"</span> &lt;&lt; <span class="text-green-300">std::endl</span>; }
                        };
                    </div>
                </div>
            </div>
        </section>

        <!-- 12. 继承和多态 -->
        <section id="section-12" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">12. 继承和多态</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 复杂继承关系和多态实现</h4>
                <p class="text-slate-300 mb-4">特点：支持多重继承、虚继承、虚函数等高级特性，C++11引入了override和final关键字。注意事项：设计继承关系时要考虑菱形继承问题，合理使用虚继承。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 继承和多态</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 虚继承示例</span><br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">Vehicle</span> {
                        <span class="text-purple-400">protected</span>:
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">std::string</span> brand;
                        <br>
                        <span class="text-purple-400">public</span>:
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">Vehicle</span>(<span class="text-purple-400">const</span> <span class="text-purple-400">std::string</span>& b) : brand(b) {}
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">virtual</span> <span class="text-purple-400">void</span> <span class="text-blue-300">start</span>() = <span class="text-yellow-300">0</span>;
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">virtual</span> <span class="text-blue-300">~Vehicle</span>() = <span class="text-purple-400">default</span>;
                        };
                        <br>
                        <span class="text-blue-300">// 虚继承</span><br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">Car</span> : <span class="text-purple-400">virtual</span> <span class="text-purple-400">public</span> <span class="text-blue-300">Vehicle</span> {
                        <span class="text-purple-400">public</span>:
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">Car</span>(<span class="text-purple-400">const</span> <span class="text-purple-400">std::string</span>& b) : <span class="text-blue-300">Vehicle</span>(b) {}
                        };
                        <br>
                        <span class="text-blue-300">// 多重继承</span><br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">ElectricCar</span> : <span class="text-purple-400">public</span> <span class="text-blue-300">Car</span> {
                        <span class="text-purple-400">private</span>:
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">double</span> batteryLevel;
                        <br>
                        <span class="text-purple-400">public</span>:
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">ElectricCar</span>(<span class="text-purple-400">const</span> <span class="text-purple-400">std::string</span>& b, <span class="text-purple-400">double</span> level) : <span class="text-blue-300">Car</span>(b), batteryLevel(level) {}
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">void</span> <span class="text-blue-300">start</span>() <span class="text-purple-400">override</span> {
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"Electric car starting silently"</span> &lt;&lt; <span class="text-green-300">std::endl</span>;
                        &nbsp;&nbsp;&nbsp;&nbsp;}
                        };
                    </div>
                </div>
            </div>
        </section>

        <!-- 13. 异常处理 -->
        <section id="section-13" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">13. 异常处理</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 高级异常处理和异常安全</h4>
                <p class="text-slate-300 mb-4">特点：支持异常规范、noexcept说明符、异常安全保证等特性，C++11增强了异常安全性。注意事项：异常安全分为基本保证、强保证和不抛异常保证三个级别。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 高级异常处理</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 自定义异常类</span><br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">CustomException</span> : <span class="text-purple-400">public</span> <span class="text-blue-300">std::exception</span> {
                        <span class="text-purple-400">private</span>:
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">std::string</span> message;
                        <br>
                        <span class="text-purple-400">public</span>:
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">CustomException</span>(<span class="text-purple-400">const</span> <span class="text-purple-400">std::string</span>& msg) : message(msg) {}
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">const</span> <span class="text-purple-400">char</span>* <span class="text-blue-300">what</span>() <span class="text-purple-400">const</span> <span class="text-purple-400">noexcept</span> <span class="text-purple-400">override</span> {
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> message.<span class="text-blue-300">c_str</span>();
                        &nbsp;&nbsp;&nbsp;&nbsp;}
                        };
                        <br>
                        <span class="text-blue-300">// 使用noexcept (C++11)</span><br>
                        <span class="text-purple-400">void</span> <span class="text-blue-300">functionThatDoesNotThrow</span>() <span class="text-purple-400">noexcept</span> {
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"This function does not throw exceptions"</span> &lt;&lt; <span class="text-green-300">std::endl</span>;
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 14. 智能指针 -->
        <section id="section-14" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">14. 智能指针</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 智能指针管理内存</h4>
                <p class="text-slate-300 mb-4">特点：C++11引入了unique_ptr、shared_ptr、weak_ptr等智能指针，实现自动内存管理。注意事项：优先使用RAII原则和智能指针，避免手动内存管理。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 智能指针</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// unique_ptr - 独占所有权</span><br>
                        <span class="text-purple-400">auto</span> uniquePtr = <span class="text-blue-300">std::make_unique</span>&lt;<span class="text-purple-400">int</span>&gt;(<span class="text-yellow-300">42</span>);
                        <span class="text-purple-400">int</span> value = *uniquePtr; <span class="text-blue-300">// 访问值</span>
                        <br>
                        <span class="text-blue-300">// shared_ptr - 共享所有权</span><br>
                        <span class="text-purple-400">auto</span> sharedPtr1 = <span class="text-blue-300">std::make_shared</span>&lt;<span class="text-purple-400">int</span>&gt;(<span class="text-yellow-300">42</span>);
                        <span class="text-purple-400">auto</span> sharedPtr2 = sharedPtr1; <span class="text-blue-300">// 引用计数增加</span>
                        <span class="text-purple-400">int</span> count = sharedPtr1.<span class="text-blue-300">use_count</span>(); <span class="text-blue-300">// 获取引用计数</span>
                        <br>
                        <span class="text-blue-300">// weak_ptr - 避免循环引用</span><br>
                        <span class="text-purple-400">std::weak_ptr</span>&lt;<span class="text-purple-400">int</span>&gt; weakPtr = sharedPtr1;
                        <span class="text-purple-400">if</span> (<span class="text-purple-400">auto</span> lockedPtr = weakPtr.<span class="text-blue-300">lock</span>()) { <span class="text-blue-300">// 检查对象是否仍然存在</span>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"Value: "</span> &lt;&lt; *lockedPtr &lt;&lt; <span class="text-green-300">std::endl</span>;
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 15. 文件操作 -->
        <section id="section-15" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">15. 文件操作</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 文件输入输出操作</h4>
                <p class="text-slate-300 mb-4">特点：支持文本文件和二进制文件操作，提供ifstream、ofstream、fstream等流类。注意事项：操作完成后要检查文件状态并关闭文件。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 文件操作</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 写入文件</span><br>
                        <span class="text-purple-400">std::ofstream</span> outFile(<span class="text-green-300">"example.txt"</span>);
                        <span class="text-purple-400">if</span> (outFile.<span class="text-blue-300">is_open</span>()) {
                        &nbsp;&nbsp;&nbsp;&nbsp;outFile &lt;&lt; <span class="text-green-300">"Hello, C++ File!"</span> &lt;&lt; <span class="text-green-300">std::endl</span>;
                        &nbsp;&nbsp;&nbsp;&nbsp;outFile &lt;&lt; <span class="text-yellow-300">42</span> &lt;&lt; <span class="text-green-300">" "</span> &lt;&lt; <span class="text-yellow-300">3.14</span> &lt;&lt; <span class="text-green-300">std::endl</span>;
                        &nbsp;&nbsp;&nbsp;&nbsp;outFile.<span class="text-blue-300">close</span>();
                        }
                        <br>
                        <span class="text-blue-300">// 读取文件</span><br>
                        <span class="text-purple-400">std::ifstream</span> inFile(<span class="text-green-300">"example.txt"</span>);
                        <span class="text-purple-400">if</span> (inFile.<span class="text-blue-300">is_open</span>()) {
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">std::string</span> line;
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">while</span> (<span class="text-purple-400">std::getline</span>(inFile, line)) {
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="text-green-300">std::cout</span> &lt;&lt; line &lt;&lt; <span class="text-green-300">std::endl</span>;
                        &nbsp;&nbsp;&nbsp;&nbsp;}
                        &nbsp;&nbsp;&nbsp;&nbsp;inFile.<span class="text-blue-300">close</span>();
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 16. Lambda表达式 -->
        <section id="section-16" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">16. Lambda表达式</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - Lambda表达式和函数式编程</h4>
                <p class="text-slate-300 mb-4">特点：C++11引入了Lambda表达式，支持闭包、捕获列表等特性。注意事项：注意捕获方式(值捕获、引用捕获)对Lambda生命周期的影响。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># Lambda表达式</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 基本Lambda表达式</span><br>
                        <span class="text-purple-400">auto</span> add = [](<span class="text-purple-400">int</span> a, <span class="text-purple-400">int</span> b) { <span class="text-purple-400">return</span> a + b; };
                        <span class="text-purple-400">int</span> result = <span class="text-blue-300">add</span>(<span class="text-yellow-300">5</span>, <span class="text-yellow-300">3</span>); <span class="text-blue-300">// 结果为 8</span>
                        <br>
                        <span class="text-blue-300">// 值捕获</span><br>
                        <span class="text-purple-400">int</span> multiplier = <span class="text-yellow-300">10</span>;
                        <span class="text-purple-400">auto</span> multiplyByTen = [multiplier](<span class="text-purple-400">int</span> x) { <span class="text-purple-400">return</span> x * multiplier; };
                        <br>
                        <span class="text-blue-300">// 引用捕获</span><br>
                        <span class="text-purple-400">auto</span> multiplyByRef = [&amp;multiplier](<span class="text-purple-400">int</span> x) { <span class="text-purple-400">return</span> x * multiplier; };
                        <br>
                        <span class="text-blue-300">// 使用Lambda配合STL算法</span><br>
                        <span class="text-purple-400">std::vector</span>&lt;<span class="text-purple-400">int</span>&gt; numbers = {<span class="text-yellow-300">1</span>, <span class="text-yellow-300">2</span>, <span class="text-yellow-300">3</span>, <span class="text-yellow-300">4</span>, <span class="text-yellow-300">5</span>};
                        <span class="text-purple-400">std::sort</span>(numbers.<span class="text-blue-300">begin</span>(), numbers.<span class="text-blue-300">end</span>(), [](<span class="text-purple-400">int</span> a, <span class="text-purple-400">int</span> b) { <span class="text-purple-400">return</span> a &gt; b; }); <span class="text-blue-300">// 降序排序</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- 17. 移动语义 -->
        <section id="section-17" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">17. 移动语义</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 移动语义和右值引用</h4>
                <p class="text-slate-300 mb-4">特点：C++11引入了移动语义，通过右值引用提高性能，避免不必要的拷贝。注意事项：合理使用std::move，理解左值和右值的区别。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 移动语义</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 移动构造函数示例</span><br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">MyClass</span> {
                        <span class="text-purple-400">private</span>:
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">std::vector</span>&lt;<span class="text-purple-400">int</span>&gt; data;
                        <br>
                        <span class="text-purple-400">public</span>:
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">MyClass</span>(<span class="text-purple-400">std::vector</span>&lt;<span class="text-purple-400">int</span>&gt; vec) : data(<span class="text-purple-400">std::move</span>(vec)) {} <span class="text-blue-300">// 移动构造</span>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">MyClass</span>(<span class="text-blue-300">MyClass</span>&& other) <span class="text-purple-400">noexcept</span> : data(<span class="text-purple-400">std::move</span>(other.data)) {} <span class="text-blue-300">// 移动构造函数</span>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">MyClass</span>& <span class="text-blue-300">operator</span>= (<span class="text-blue-300">MyClass</span>&& other) <span class="text-purple-400">noexcept</span> { <span class="text-green-300">// 移动赋值</span>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">if</span> (<span class="text-purple-400">this</span> != &amp;other) {
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data = <span class="text-purple-400">std::move</span>(other.data);
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> *<span class="text-purple-400">this</span>;
                        &nbsp;&nbsp;&nbsp;&nbsp;}
                        };
                        <br>
                        <span class="text-blue-300">// 使用移动语义</span><br>
                        <span class="text-purple-400">std::vector</span>&lt;<span class="text-purple-400">int</span>&gt; vec = {1, 2, 3, 4, 5};
                        <span class="text-blue-300">MyClass</span> obj1(<span class="text-purple-400">std::move</span>(vec)); <span class="text-blue-300">// 触发移动构造</span>
                        <br>
                        <span class="text-purple-400">std::vector</span>&lt;<span class="text-purple-400">int</span>&gt; vec2 = {6, 7, 8, 9, 10};
                        <span class="text-blue-300">MyClass</span> obj2(vec2);
                        obj2 = <span class="text-blue-300">MyClass</span>(<span class="text-purple-400">std::move</span>(vec2)); <span class="text-blue-300">// 触发移动赋值</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- 18. 基于范围的for循环 -->
        <section id="section-18" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">18. 基于范围的for循环</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 基于范围的for循环 (Range-based for loop)</h4>
                <p class="text-slate-300 mb-4">特点：C++11引入了基于范围的for循环，使遍历容器和数组更加简洁易读。语法：for (declaration : expression)，其中expression是一个序列，declaration是元素的声明。注意事项：可以使用auto关键字和引用，避免不必要的拷贝。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 基于范围的for循环</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 遍历数组</span><br>
                        <span class="text-purple-400">int</span> arr[] = {1, 2, 3, 4, 5};<br>
                        <span class="text-purple-400">for</span> (<span class="text-purple-400">int</span> element : arr) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; element &lt;&lt; <span class="text-green-300">" "</span>;<br>
                        }<br>
                        std::cout &lt;&lt; std::endl;<br>
                        <br>
                        <span class="text-blue-300">// 遍历vector</span><br>
                        <span class="text-purple-400">std::vector</span>&lt;<span class="text-purple-400">int</span>&gt; vec = {10, 20, 30, 40, 50};<br>
                        <span class="text-purple-400">for</span> (<span class="text-purple-400">const</span> <span class="text-purple-400">auto</span>& item : vec) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; item &lt;&lt; <span class="text-green-300">" "</span>;<br>
                        }<br>
                        std::cout &lt;&lt; std::endl;<br>
                        <br>
                        <span class="text-blue-300">// 修改容器中的元素</span><br>
                        <span class="text-purple-400">for</span> (<span class="text-purple-400">auto</span>& item : vec) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;item *= 2; <span class="text-blue-300">// 修改原始元素</span><br>
                        }<br>
                        <br>
                        <span class="text-blue-300">// 遍历字符串</span><br>
                        <span class="text-purple-400">std::string</span> str = <span class="text-green-300">"Hello"</span>;<br>
                        <span class="text-purple-400">for</span> (<span class="text-purple-400">char</span> c : str) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; c &lt;&lt; <span class="text-green-300">" "</span>;<br>
                        }<br>
                        std::cout &lt;&lt; std::endl;<br>
                        <br>
                        <span class="text-blue-300">// 遍历关联容器</span><br>
                        <span class="text-purple-400">std::map</span>&lt;<span class="text-purple-400">std::string</span>, <span class="text-purple-400">int</span>&gt; myMap = {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;{<span class="text-green-300">"apple"</span>, 1}, {<span class="text-green-300">"banana"</span>, 2}, {<span class="text-green-300">"orange"</span>, 3}<br>
                        };<br>
                        <span class="text-purple-400">for</span> (<span class="text-purple-400">const</span> <span class="text-purple-400">auto</span>& pair : myMap) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; pair.first &lt;&lt; <span class="text-green-300">": "</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 19. nullptr关键字 -->
        <section id="section-19" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">19. nullptr关键字</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - nullptr关键字</h4>
                <p class="text-slate-300 mb-4">特点：C++11引入了nullptr关键字，作为空指针的专用字面量，解决了传统NULL宏存在的类型安全问题。注意事项：使用nullptr代替NULL或0来表示空指针，避免函数重载时的二义性问题。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># nullptr的使用</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 传统C风格的空指针表示（不推荐）</span><br>
                        <span class="text-purple-400">int</span>* ptr1 = <span class="text-yellow-300">0</span>;<br>
                        <span class="text-purple-400">int</span>* ptr2 = NULL;<br>
                        <br>
                        <span class="text-blue-300">// C++11推荐的空指针表示</span><br>
                        <span class="text-purple-400">int</span>* ptr3 = <span class="text-purple-400">nullptr</span>;<br>
                        <br>
                        <span class="text-blue-300">// nullptr的类型安全性</span><br>
                        <span class="text-purple-400">void</span> <span class="text-yellow-300">func</span>(<span class="text-purple-400">int</span> i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"调用func(int): "</span> &lt;&lt; i &lt;&lt; std::endl;<br>
                        }<br>
                        <br>
                        <span class="text-purple-400">void</span> <span class="text-yellow-300">func</span>(<span class="text-purple-400">int</span>* ptr) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"调用func(int*): "</span> &lt;&lt; <span class="text-purple-400">static_cast</span>&lt;<span class="text-purple-400">void</span>*&gt;(ptr) &lt;&lt; std::endl;<br>
                        }<br>
                        <br>
                        <span class="text-purple-400">func</span>(<span class="text-yellow-300">0</span>); <span class="text-blue-300">// 调用func(int)</span><br>
                        <span class="text-purple-400">func</span>(NULL); <span class="text-blue-300">// 可能调用func(int)或func(int*)，存在二义性</span><br>
                        <span class="text-purple-400">func</span>(<span class="text-purple-400">nullptr</span>); <span class="text-blue-300">// 明确调用func(int*)</span><br>
                        <br>
                        <span class="text-blue-300">// 检查指针是否为空</span><br>
                        <span class="text-purple-400">if</span> (ptr3 == <span class="text-purple-400">nullptr</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"ptr3是空指针"</span> &lt;&lt; std::endl;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 20. 强类型枚举 -->
        <section id="section-20" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">20. 强类型枚举</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 强类型枚举 (Strongly-typed enums)</h4>
                <p class="text-slate-300 mb-4">特点：C++11引入了enum class（强类型枚举），解决了传统枚举的类型安全问题和命名空间污染问题。注意事项：强类型枚举不能隐式转换为整型，必须显式转换；枚举值作用域限制在枚举类内部，避免命名冲突。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 强类型枚举的使用</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 传统枚举（存在类型安全和命名空间问题）</span><br>
                        <span class="text-purple-400">enum</span> Color { RED, GREEN, BLUE };<br>
                        <span class="text-purple-400">enum</span> Status { FAILED, SUCCESS }; <span class="text-blue-300">// 与Color中的值冲突</span><br>
                        <br>
                        <span class="text-blue-300">// 强类型枚举（类型安全）</span><br>
                        <span class="text-purple-400">enum class</span> ColorClass { RED, GREEN, BLUE };<br>
                        <span class="text-purple-400">enum class</span> StatusClass { FAILED, SUCCESS }; <span class="text-blue-300">// 不会冲突</span><br>
                        <br>
                        <span class="text-blue-300">// 使用强类型枚举</span><br>
                        ColorClass color = ColorClass::RED;<br>
                        StatusClass status = StatusClass::SUCCESS;<br>
                        <br>
                        <span class="text-blue-300">// 强类型枚举不能隐式转换为整型</span><br>
                        <span class="text-purple-400">int</span> num = <span class="text-purple-400">static_cast</span>&lt;<span class="text-purple-400">int</span>&gt;(ColorClass::RED); <span class="text-blue-300">// 显式转换</span><br>
                        <br>
                        <span class="text-blue-300">// 指定底层类型</span><br>
                        <span class="text-purple-400">enum class</span> Priority : <span class="text-purple-400">unsigned</span> <span class="text-purple-400">char</span> { LOW, MEDIUM, HIGH };<br>
                        Priority priority = Priority::HIGH;<br>
                        <br>
                        <span class="text-blue-300">// 强类型枚举的优势示例</span><br>
                        <span class="text-purple-400">void</span> <span class="text-yellow-300">SetColor</span>(ColorClass c) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">if</span> (c == ColorClass::RED) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"设置颜色为红色"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        }<br>
                        <br>
                        <span class="text-blue-300">// SetColor(RED); // 编译错误，类型不匹配</span><br>
                        SetColor(ColorClass::RED); <span class="text-blue-300">// 正确的调用方式</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- 21. 可变参数模板 -->
        <section id="section-21" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">21. 可变参数模板</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 可变参数模板 (Variadic templates)</h4>
                <p class="text-slate-300 mb-4">特点：C++11引入了可变参数模板，允许模板接受任意数量和类型的参数，提供了更灵活的泛型编程能力。注意事项：使用参数包（parameter pack）和展开操作（pack expansion）来处理参数；递归展开或使用折叠表达式（C++17）来处理参数包。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 可变参数模板的使用</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 可变参数模板函数</span><br>
                        <span class="text-purple-400">template</span>&lt;<span class="text-purple-400">typename</span>... Args&gt;<br>
                        <span class="text-purple-400">void</span> <span class="text-yellow-300">Print</span>(Args... args) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"参数数量: "</span> &lt;&lt; <span class="text-purple-400">sizeof</span>...(args) &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;(<span class="text-purple-400">void</span>)std::initializer_list&lt;<span class="text-purple-400">int</span>&gt;{ ((std::cout &lt;&lt; args &lt;&lt; <span class="text-green-300">" "</span>), 0)... };<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl;<br>
                        }<br>
                        <br>
                        <span class="text-blue-300">// 递归方式展开参数包</span><br>
                        <span class="text-purple-400">template</span>&lt;<span class="text-purple-400">typename</span> T&gt;<br>
                        <span class="text-purple-400">void</span> <span class="text-yellow-300">PrintRecursive</span>(T&amp;&amp; t) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; t &lt;&lt; std::endl;<br>
                        }<br>
                        <br>
                        <span class="text-purple-400">template</span>&lt;<span class="text-purple-400">typename</span> T, <span class="text-purple-400">typename</span>... Args&gt;<br>
                        <span class="text-purple-400">void</span> <span class="text-yellow-300">PrintRecursive</span>(T&amp;&amp; t, Args&amp;&amp;... args) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; t &lt;&lt; <span class="text-green-300">" "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;PrintRecursive(args...);<br>
                        }<br>
                        <br>
                        <span class="text-blue-300">// 可变参数模板类</span><br>
                        <span class="text-purple-400">template</span>&lt;<span class="text-purple-400">typename</span>... Types&gt;<br>
                        <span class="text-purple-400">struct</span> <span class="text-blue-300">Tuple</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">Tuple</span>(Types... args) : values(args...) {}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::tuple&lt;Types...&gt; values;<br>
                        };<br>
                        <br>
                        <span class="text-blue-300">// 使用示例</span><br>
                        Print(1, 2.5, <span class="text-green-300">"hello"</span>, <span class="text-green-300">'c'</span>);<br>
                        PrintRecursive(10, <span class="text-green-300">"world"</span>, 3.14);<br>
                        <br>
                        Tuple&lt;<span class="text-purple-400">int</span>, <span class="text-purple-400">double</span>, std::string&gt; t(42, 3.14, <span class="text-green-300">"example"</span>);
                    </div>
                </div>
            </div>
        </section>

        <!-- 22. 线程库 -->
        <section id="section-22" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">22. 线程库</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 线程库 (Threading library)</h4>
                <p class="text-slate-300 mb-4">特点：C++11引入了标准线程库，提供了跨平台的多线程编程支持，包括std::thread、std::mutex、std::condition_variable等组件。注意事项：需要链接线程库（如-lpthread），注意避免竞态条件和死锁问题。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 线程库的使用</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">#include &lt;thread&gt;</span><br>
                        <span class="text-blue-300">#include &lt;mutex&gt;</span><br>
                        <span class="text-blue-300">#include &lt;condition_variable&gt;</span><br>
                        <span class="text-blue-300">#include &lt;iostream&gt;</span><br>
                        <br>
                        <span class="text-purple-400">int</span> shared_data = 0;<br>
                        std::mutex mtx;<br>
                        <br>
                        <span class="text-purple-400">void</span> <span class="text-yellow-300">worker</span>(<span class="text-purple-400">int</span> id) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::lock_guard&lt;std::mutex&gt; lock(mtx);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"线程 "</span> &lt;&lt; id &lt;&lt; <span class="text-green-300">" 修改数据: "</span> &lt;&lt; ++shared_data &lt;&lt; std::endl;<br>
                        }<br>
                        <br>
                        <span class="text-purple-400">void</span> <span class="text-yellow-300">producer</span>(std::condition_variable&amp; cv, <span class="text-purple-400">bool</span>& ready) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::this_thread::sleep_for(std::chrono::seconds(1));<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;{<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::lock_guard&lt;std::mutex&gt; lock(mtx);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ready = <span class="text-purple-400">true</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"生产者: 数据已准备"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;cv.notify_one();<br>
                        }<br>
                        <br>
                        <span class="text-purple-400">void</span> <span class="text-yellow-300">consumer</span>(std::condition_variable&amp; cv, <span class="text-purple-400">bool</span>& ready) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;{<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::unique_lock&lt;std::mutex&gt; lock(mtx);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cv.wait(lock, [&amp;]{ <span class="text-purple-400">return</span> ready; });<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"消费者: 数据已接收"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        }<br>
                        <br>
                        <span class="text-blue-300">// 使用示例</span><br>
                        <span class="text-purple-400">int</span> main() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"主线程 ID: "</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 创建线程</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::thread t1(worker, 1);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::thread t2(worker, 2);<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 等待线程完成</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;t1.join();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;t2.join();<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"共享数据最终值: "</span> &lt;&lt; shared_data &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 条件变量示例</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">bool</span> ready = <span class="text-purple-400">false</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::condition_variable cv;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::thread producer_thread(producer, std::ref(cv), std::ref(ready));<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::thread consumer_thread(consumer, std::ref(cv), std::ref(ready));<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;producer_thread.join();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;consumer_thread.join();<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> 0;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 23. 正则表达式库 -->
        <section id="section-23" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">23. 正则表达式库</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 正则表达式库 (Regular expression library)</h4>
                <p class="text-slate-300 mb-4">特点：C++11引入了正则表达式库，提供了std::regex、std::regex_match、std::regex_search等组件，用于模式匹配和文本处理。注意事项：正则表达式语法可能因实现而异，注意性能开销，复杂表达式可能影响程序效率。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 正则表达式库的使用</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">#include &lt;regex&gt;</span><br>
                        <span class="text-blue-300">#include &lt;iostream&gt;</span><br>
                        <span class="text-blue-300">#include &lt;string&gt;</span><br>
                        <br>
                        <span class="text-purple-400">void</span> <span class="text-yellow-300">regex_examples</span>() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string text = <span class="text-green-300">"Email: example@domain.com and phone: 123-456-7890"</span>;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 邮箱匹配</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::regex email_pattern(<span class="text-green-300">R"(\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b)"</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::smatch email_match;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">if</span> (std::regex_search(text, email_match, email_pattern)) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"找到邮箱: "</span> &lt;&lt; email_match[0] &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 电话号码匹配</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::regex phone_pattern(<span class="text-green-300">R"(\b\d{3}-\d{3}-\d{4}\b)"</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::smatch phone_match;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string::const_iterator search_start(text.cbegin());<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">while</span> (std::regex_search(search_start, text.cend(), phone_match, phone_pattern)) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"找到电话: "</span> &lt;&lt; phone_match[0] &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;search_start = phone_match.suffix().first;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 完全匹配</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string date = <span class="text-green-300">"2023-12-25"</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::regex date_pattern(<span class="text-green-300">R"(^\d{4}-\d{2}-\d{2}$)"</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">if</span> (std::regex_match(date, date_pattern)) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"日期格式正确"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 替换操作</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string original = <span class="text-green-300">"Hello, World! Welcome to World!"</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::regex world_pattern(<span class="text-green-300">"World"</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string replaced = std::regex_replace(original, world_pattern, <span class="text-green-300">"C++"</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"替换后: "</span> &lt;&lt; replaced &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 捕获组示例</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string url = <span class="text-green-300">"https://www.example.com/path/to/page"</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::regex url_pattern(<span class="text-green-300">R"(https?)://([^/]+)/(.*)"</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::smatch url_match;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">if</span> (std::regex_match(url, url_match, url_pattern)) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"协议: "</span> &lt;&lt; url_match[1] &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"域名: "</span> &lt;&lt; url_match[2] &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"路径: "</span> &lt;&lt; url_match[3] &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        }<br>
                        <br>
                        <span class="text-purple-400">int</span> main() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;regex_examples();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> 0;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 24. std::function和std::bind -->
        <section id="section-24" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">24. std::function和std::bind</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - std::function和std::bind (std::function and std::bind)</h4>
                <p class="text-slate-300 mb-4">特点：std::function是一个通用的函数包装器，可以存储、复制和调用任何可调用对象；std::bind用于绑定函数参数，创建新的可调用对象。注意事项：std::function使用类型擦除技术，有一定性能开销；std::bind可与lambda表达式配合使用，但C++11后lambda通常更简洁。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># std::function和std::bind的使用</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">#include &lt;functional&gt;</span><br>
                        <span class="text-blue-300">#include &lt;iostream&gt;</span><br>
                        <span class="text-blue-300">#include &lt;vector&gt;</span><br>
                        <br>
                        <span class="text-purple-400">int</span> <span class="text-yellow-300">add</span>(<span class="text-purple-400">int</span> a, <span class="text-purple-400">int</span> b) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> a + b;<br>
                        }<br>
                        <br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">Calculator</span> {<br>
                        <span class="text-purple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">int</span> <span class="text-yellow-300">multiply</span>(<span class="text-purple-400">int</span> x, <span class="text-purple-400">int</span> y) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> x * y;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">int</span> <span class="text-yellow-300">calculate</span>(<span class="text-purple-400">int</span> a, <span class="text-purple-400">int</span> b, <span class="text-purple-400">int</span> c) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> (a + b) * c;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        };<br>
                        <br>
                        <span class="text-purple-400">void</span> <span class="text-yellow-300">function_bind_examples</span>() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// std::function示例</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::function&lt;<span class="text-purple-400">int</span>(<span class="text-purple-400">int</span>, <span class="text-purple-400">int</span>)&gt; func;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 绑定普通函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;func = add;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"add(5, 3) = "</span> &lt;&lt; func(5, 3) &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 绑定lambda表达式</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;func = [](<span class="text-purple-400">int</span> a, <span class="text-purple-400">int</span> b) { <span class="text-purple-400">return</span> a * b; };<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"lambda(5, 3) = "</span> &lt;&lt; func(5, 3) &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 绑定成员函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Calculator calc;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;func = std::bind(&amp;Calculator::multiply, &amp;calc, std::placeholders::_1, std::placeholders::_2);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"multiply(5, 3) = "</span> &lt;&lt; func(5, 3) &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 使用bind创建部分应用函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;auto multiply_by_10 = std::bind(&amp;Calculator::multiply, &amp;calc, 10, std::placeholders::_1);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"multiply_by_10(5) = "</span> &lt;&lt; multiply_by_10(5) &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 绑定带默认参数的函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;auto calc_partial = std::bind(&amp;Calculator::calculate, &amp;calc, std::placeholders::_1, 5, std::placeholders::_2);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"calc_partial(3, 2) = "</span> &lt;&lt; calc_partial(3, 2) &lt;&lt; std::endl; <span class="text-blue-300">// (3+5)*2 = 16</span><br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 在容器中存储不同类型的可调用对象</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;std::function&lt;<span class="text-purple-400">int</span>(<span class="text-purple-400">int</span>, <span class="text-purple-400">int</span>)&gt;&gt; operations;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;operations.push_back(add);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;operations.push_back([](<span class="text-purple-400">int</span> a, <span class="text-purple-400">int</span> b) { <span class="text-purple-400">return</span> a - b; });<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;operations.push_back(std::bind(&amp;Calculator::multiply, &amp;calc, std::placeholders::_1, std::placeholders::_2));<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"\n操作列表:"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">for</span> (<span class="text-purple-400">size_t</span> i = 0; i &lt; operations.size(); ++i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"操作 "</span> &lt;&lt; i + 1 &lt;&lt; <span class="text-green-300">": "</span> &lt;&lt; operations[i](10, 5) &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        }<br>
                        <br>
                        <span class="text-purple-400">int</span> main() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;function_bind_examples();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> 0;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 25. 新的字符串字面量 -->
        <section id="section-25" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">25. 新的字符串字面量</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 新的字符串字面量 (New string literals)</h4>
                <p class="text-slate-300 mb-4">特点：C++11引入了原始字符串字面量（R-strings）和用户定义字面量，使字符串处理更加灵活。注意事项：原始字符串字面量使用R"(...)"语法，避免转义字符；用户定义字面量需要定义后缀操作符函数。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 新的字符串字面量的使用</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">#include &lt;iostream&gt;</span><br>
                        <span class="text-blue-300">#include &lt;string&gt;</span><br>
                        <span class="text-blue-300">#include &lt;chrono&gt;</span><br>
                        <br>
                        <span class="text-purple-400">void</span> <span class="text-yellow-300">string_literal_examples</span>() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 原始字符串字面量</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string raw_string = R<span class="text-green-300">"(
                        &nbsp;&nbsp;&nbsp;&nbsp;这是多行字符串，
                        &nbsp;&nbsp;&nbsp;&nbsp;包含"引号"和\转义字符\，
                        &nbsp;&nbsp;&nbsp;&nbsp;无需转义！
                        )"</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"原始字符串:\n"</span> &lt;&lt; raw_string &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 原始字符串中的正则表达式</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string regex_pattern = R<span class="text-green-300">"(\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b)"</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"\n正则表达式: "</span> &lt;&lt; regex_pattern &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 原始字符串用于SQL查询</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string sql_query = R<span class="text-green-300">"(SELECT * FROM users WHERE name = "John" AND age &gt; 18)"</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"\nSQL查询: "</span> &lt;&lt; sql_query &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 不同分隔符的原始字符串</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string custom_delim = R<span class="text-green-300">"delimiter(This string contains " and ) characters without escaping)delimiter"</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"\n自定义分隔符: "</span> &lt;&lt; custom_delim &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 用户定义字面量示例</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">long</span> <span class="text-purple-400">long</span> <span class="text-purple-400">operator</span><span class="text-purple-400">""</span>_km(<span class="text-purple-400">unsigned</span> <span class="text-purple-400">long</span> <span class="text-purple-400">long</span> value) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> value * 1000; <span class="text-blue-300">// 转换为米</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">long</span> <span class="text-purple-400">long</span> <span class="text-purple-400">operator</span><span class="text-purple-400">""</span>_m(<span class="text-purple-400">unsigned</span> <span class="text-purple-400">long</span> <span class="text-purple-400">long</span> value) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> value; <span class="text-blue-300">// 保持米单位</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">double</span> <span class="text-purple-400">operator</span><span class="text-purple-400">""</span>_cm(<span class="text-purple-400">long</span> <span class="text-purple-400">double</span> value) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> value / 100.0; <span class="text-blue-300">// 转换为米</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 使用用户定义字面量</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">auto</span> distance1 = 5_km; <span class="text-blue-300">// 5000米</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">auto</span> distance2 = 10_m; <span class="text-blue-300">// 10米</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">auto</span> distance3 = 150.0_cm; <span class="text-blue-300">// 1.5米</span><br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"\n距离计算:"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"5_km = "</span> &lt;&lt; distance1 &lt;&lt; <span class="text-green-300">" 米"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"10_m = "</span> &lt;&lt; distance2 &lt;&lt; <span class="text-green-300">" 米"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"150.0_cm = "</span> &lt;&lt; distance3 &lt;&lt; <span class="text-green-300">" 米"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"总距离: "</span> &lt;&lt; (distance1 + distance2 + distance3) &lt;&lt; <span class="text-green-300">" 米"</span> &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 时间字面量示例</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">using</span> <span class="text-purple-400">namespace</span> std::chrono_literals;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">auto</span> duration = 24h + 30min + 45s; <span class="text-blue-300">// C++14风格，需要#include &lt;chrono&gt;</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"\n时间计算示例（需要C++14）"</span> &lt;&lt; std::endl;<br>
                        }<br>
                        <br>
                        <span class="text-purple-400">int</span> main() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;string_literal_examples();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> 0;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 26. 委托构造函数和继承构造函数 -->
        <section id="section-26" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">26. 委托构造函数和继承构造函数</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 委托构造函数和继承构造函数 (Delegating and Inheriting constructors)</h4>
                <p class="text-slate-300 mb-4">特点：委托构造函数允许一个构造函数调用同一个类的另一个构造函数，避免代码重复；继承构造函数允许派生类继承基类的构造函数。注意事项：委托构造函数使用冒号语法调用同一类的其他构造函数；继承构造函数使用using声明引入基类构造函数。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 委托构造函数和继承构造函数的使用</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">#include &lt;iostream&gt;</span><br>
                        <span class="text-blue-300">#include &lt;string&gt;</span><br>
                        <br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">Rectangle</span> {<br>
                        <span class="text-purple-400">private</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">double</span> width, height;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string color;<br>
                        <br>
                        <span class="text-purple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 基础构造函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Rectangle(<span class="text-purple-400">double</span> w, <span class="text-purple-400">double</span> h, <span class="text-purple-400">const</span> std::string&amp; c) : width(w), height(h), color(c) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"创建矩形: "</span> &lt;&lt; width &lt;&lt; <span class="text-green-300">"x"</span> &lt;&lt; height &lt;&lt; <span class="text-green-300">" 颜色: "</span> &lt;&lt; color &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 委托构造函数 - 使用默认颜色</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Rectangle(<span class="text-purple-400">double</span> w, <span class="text-purple-400">double</span> h) : Rectangle(w, h, <span class="text-green-300">"白色"</span>) {}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 委托构造函数 - 创建正方形</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Rectangle(<span class="text-purple-400">double</span> side) : Rectangle(side, side, <span class="text-green-300">"白色"</span>) {}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 默认构造函数 - 委托给其他构造函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Rectangle() : Rectangle(1.0, 1.0, <span class="text-green-300">"白色"</span>) {}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 获取信息的方法</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">double</span> getArea() <span class="text-purple-400">const</span> { <span class="text-purple-400">return</span> width * height; }<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">double</span> getPerimeter() <span class="text-purple-400">const</span> { <span class="text-purple-400">return</span> 2 * (width + height); }<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">void</span> printInfo() <span class="text-purple-400">const</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"矩形: "</span> &lt;&lt; width &lt;&lt; <span class="text-green-300">"x"</span> &lt;&lt; height &lt;&lt; <span class="text-green-300">" 颜色: "</span> &lt;&lt; color<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; <span class="text-green-300">" 面积: "</span> &lt;&lt; getArea() &lt;&lt; <span class="text-green-300">" 周长: "</span> &lt;&lt; getPerimeter() &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        };<br>
                        <br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">Shape</span> {<br>
                        <span class="text-purple-400">protected</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string name;<br>
                        <span class="text-purple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Shape(<span class="text-purple-400">const</span> std::string&amp; n) : name(n) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"创建形状: "</span> &lt;&lt; name &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Shape(<span class="text-purple-400">const</span> std::string&amp; n, <span class="text-purple-400">int</span> id) : name(n + <span class="text-green-300">"-"</span> + std::to_string(id)) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"创建形状: "</span> &lt;&lt; name &lt;&lt; <span class="text-green-300">" (ID: "</span> + std::to_string(id) + <span class="text-green-300">")"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string getName() <span class="text-purple-400">const</span> { <span class="text-purple-400">return</span> name; }<br>
                        };<br>
                        <br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">Circle</span> : <span class="text-purple-400">public</span> Shape {<br>
                        <span class="text-purple-400">private</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">double</span> radius;<br>
                        <br>
                        <span class="text-purple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 继承基类的构造函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">using</span> Shape::Shape;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 特定的Circle构造函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Circle(<span class="text-purple-400">double</span> r) : Shape(<span class="text-green-300">"圆形"</span>), radius(r) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"半径: "</span> &lt;&lt; radius &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Circle(<span class="text-purple-400">const</span> std::string&amp; n, <span class="text-purple-400">double</span> r) : Shape(n), radius(r) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"半径: "</span> &lt;&lt; radius &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">double</span> getArea() <span class="text-purple-400">const</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> 3.14159 * radius * radius;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        };<br>
                        <br>
                        <span class="text-purple-400">void</span> <span class="text-yellow-300">constructor_examples</span>() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"=== 委托构造函数示例 ==="</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Rectangle rect1; <span class="text-blue-300">// 调用默认构造函数，委托给三参数构造函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Rectangle rect2(5.0); <span class="text-blue-300">// 调用单参数构造函数，委托创建正方形</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Rectangle rect3(3.0, 4.0); <span class="text-blue-300">// 调用两参数构造函数，委托给三参数构造函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Rectangle rect4(2.0, 3.0, <span class="text-green-300">"红色"</span>); <span class="text-blue-300">// 直接调用三参数构造函数</span><br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"\n=== 继承构造函数示例 ==="</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Circle circle1(<span class="text-green-300">"圆形A"</span>); <span class="text-blue-300">// 使用继承的构造函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Circle circle2(<span class="text-green-300">"圆形B"</span>, 123); <span class="text-blue-300">// 使用继承的构造函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Circle circle3(5.0); <span class="text-blue-300">// 使用Circle自己的构造函数</span><br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"\n=== 矩形信息 ==="</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;rect1.printInfo();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;rect2.printInfo();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;rect3.printInfo();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;rect4.printInfo();<br>
                        }<br>
                        <br>
                        <span class="text-purple-400">int</span> main() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;constructor_examples();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> 0;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 27. final/override控制 -->
        <section id="section-27" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">27. final/override控制</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - final/override控制 (final/override control)</h4>
                <p class="text-slate-300 mb-4">特点：override关键字确保派生类函数重写基类虚函数，提供编译时检查；final关键字防止类被继承或虚函数被重写。注意事项：使用override可以避免因函数签名不匹配导致的错误；final用于限制继承层次结构。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># final/override控制的使用</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">#include &lt;iostream&gt;</span><br>
                        <span class="text-blue-300">#include &lt;string&gt;</span><br>
                        <br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">Animal</span> {<br>
                        <span class="text-purple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">virtual</span> <span class="text-purple-400">void</span> speak() <span class="text-purple-400">const</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"动物发出声音"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">virtual</span> <span class="text-purple-400">void</span> move() <span class="text-purple-400">const</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"动物移动"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">virtual</span> <span class="text-purple-400">std::string</span> getName() <span class="text-purple-400">const</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> <span class="text-green-300">"未知动物"</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">virtual</span> ~Animal() = <span class="text-purple-400">default</span>;<br>
                        };<br>
                        <br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">Dog</span> : <span class="text-purple-400">public</span> Animal {<br>
                        <span class="text-purple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">void</span> speak() <span class="text-purple-400">const</span> <span class="text-purple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"狗: 汪汪!"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">void</span> move() <span class="text-purple-400">const</span> <span class="text-purple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"狗跑得很快"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">std::string</span> getName() <span class="text-purple-400">const</span> <span class="text-purple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> <span class="text-green-300">"狗"</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 使用final防止这个函数被进一步重写</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">void</span> bark() <span class="text-purple-400">const</span> <span class="text-purple-400">final</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"特定的狗叫声"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        };<br>
                        <br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">Cat</span> : <span class="text-purple-400">public</span> Animal {<br>
                        <span class="text-purple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">void</span> speak() <span class="text-purple-400">const</span> <span class="text-purple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"猫: 喵喵!"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">void</span> move() <span class="text-purple-400">const</span> <span class="text-purple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"猫优雅地走"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">std::string</span> getName() <span class="text-purple-400">const</span> <span class="text-purple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> <span class="text-green-300">"猫"</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        };<br>
                        <br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">GoldenRetriever</span> : <span class="text-purple-400">public</span> Dog {<br>
                        <span class="text-purple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">void</span> speak() <span class="text-purple-400">const</span> <span class="text-purple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"金毛: 汪汪汪!"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">void</span> move() <span class="text-purple-400">const</span> <span class="text-purple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"金毛跑得特别开心"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 不能重写Dog的bark()函数，因为它是final的</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// void bark() const override { } // 这会引发编译错误</span><br>
                        };<br>
                        <br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">SpecialDog</span> : <span class="text-purple-400">public</span> Dog {<br>
                        <span class="text-purple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">void</span> speak() <span class="text-purple-400">const</span> <span class="text-purple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"特殊狗: 汪!"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        };<br>
                        <br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">FinalDog</span> final : <span class="text-purple-400">public</span> SpecialDog {<br>
                        <span class="text-purple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">void</span> speak() <span class="text-purple-400">const</span> <span class="text-purple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"终极狗: 汪汪汪汪!"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// FinalDog不能被继承，因为它是final的</span><br>
                        };<br>
                        <br>
                        <span class="text-purple-400">void</span> <span class="text-yellow-300">override_final_examples</span>() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"=== 基类Animal示例 ==="</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Animal animal;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;animal.speak();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;animal.move();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"名称: "</span> &lt;&lt; animal.getName() &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"\n=== Dog类示例 ==="</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Dog dog;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;dog.speak();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;dog.move();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"名称: "</span> &lt;&lt; dog.getName() &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;dog.bark();<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"\n=== Cat类示例 ==="</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Cat cat;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;cat.speak();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;cat.move();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"名称: "</span> &lt;&lt; cat.getName() &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"\n=== GoldenRetriever类示例 ==="</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;GoldenRetriever golden;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;golden.speak();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;golden.move();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"名称: "</span> &lt;&lt; golden.getName() &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"\n=== 多态性示例 ==="</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Animal* animals[] = {&amp;animal, &amp;dog, &amp;cat, &amp;golden};<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">for</span> (<span class="text-purple-400">int</span> i = 0; i &lt; 4; ++i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animals[i]-&gt;speak();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animals[i]-&gt;move();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"名称: "</span> &lt;&lt; animals[i]-&gt;getName() &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"---"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        }<br>
                        <br>
                        <span class="text-purple-400">int</span> main() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;override_final_examples();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> 0;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 28. 原子操作 -->
        <section id="section-28" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">28. 原子操作</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 原子操作 (Atomic Operations)</h4>
                <p class="text-slate-300 mb-4">特点：原子操作保证操作的不可分割性，避免多线程环境下的数据竞争；提供内存顺序控制选项。注意事项：适用于需要线程安全但又不想使用互斥锁的简单操作；注意选择合适的内存顺序以平衡性能和安全性。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 原子操作的使用</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">#include &lt;iostream&gt;</span><br>
                        <span class="text-blue-300">#include &lt;thread&gt;</span><br>
                        <span class="text-blue-300">#include &lt;vector&gt;</span><br>
                        <span class="text-blue-300">#include &lt;atomic&gt;</span><br>
                        <span class="text-blue-300">#include &lt;chrono&gt;</span><br>
                        <br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">Counter</span> {<br>
                        <span class="text-purple-400">private</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::atomic&lt;<span class="text-purple-400">int</span>&gt; count{0};<br>
                        <br>
                        <span class="text-purple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">void</span> increment() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count.fetch_add(1, std::memory_order_relaxed);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">int</span> get() <span class="text-purple-400">const</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> count.load();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">void</span> reset() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count.store(0);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        };<br>
                        <br>
                        <span class="text-purple-400">void</span> <span class="text-yellow-300">atomic_examples</span>() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"=== 原子操作示例 ==="</span> &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 基本原子类型操作</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::atomic&lt;<span class="text-purple-400">int</span>&gt; atomic_int{0};<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::atomic&lt;<span class="text-purple-400">bool</span>&gt; atomic_bool{<span class="text-purple-400">false</span>};<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::atomic&lt;<span class="text-purple-400">long</span>&gt; atomic_long{100};<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 原子加法操作</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;atomic_int.fetch_add(5);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"原子加法后: "</span> &lt;&lt; atomic_int.load() &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 原子减法操作</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;atomic_int.fetch_sub(2);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"原子减法后: "</span> &lt;&lt; atomic_int.load() &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 原子比较交换操作</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">int</span> expected = 3;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">int</span> desired = 10;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">bool</span> success = atomic_int.compare_exchange_strong(expected, desired);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"比较交换: "</span> &lt;&lt; (success ? <span class="text-green-300">"成功"</span> : <span class="text-green-300">"失败"</span>) &lt;&lt; <span class="text-green-300">", 值: "</span> &lt;&lt; atomic_int.load() &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 使用自定义Counter类</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Counter counter;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;std::thread&gt; threads;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 创建多个线程来增加计数器</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">const</span> <span class="text-purple-400">int</span> num_threads = 5;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">const</span> <span class="text-purple-400">int</span> increments_per_thread = 1000;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">for</span> (<span class="text-purple-400">int</span> i = 0; i &lt; num_threads; ++i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threads.emplace_back([&amp;counter]() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">for</span> (<span class="text-purple-400">int</span> j = 0; j &lt; increments_per_thread; ++j) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter.increment();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 等待所有线程完成</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">for</span> (<span class="text-purple-400">auto</span>&amp; t : threads) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.join();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"多线程计数器结果: "</span> &lt;&lt; counter.get() &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"预期结果: "</span> &lt;&lt; num_threads * increments_per_thread &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 原子标志示例</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::atomic_flag flag = ATOMIC_FLAG_INIT;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">if</span> (flag.test_and_set()) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"标志已被设置"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;} <span class="text-purple-400">else</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"标志未被设置，现在设置"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag.clear();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 内存顺序示例</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::atomic&lt;<span class="text-purple-400">int</span>&gt; relaxed_counter{0};<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::atomic&lt;<span class="text-purple-400">int</span>&gt; acquire_counter{0};<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::atomic&lt;<span class="text-purple-400">int</span>&gt; release_counter{0};<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;relaxed_counter.store(1, std::memory_order_relaxed);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;acquire_counter.store(2, std::memory_order_acquire);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;release_counter.store(3, std::memory_order_release);<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"内存顺序示例 - Relaxed: "</span> &lt;&lt; relaxed_counter.load(std::memory_order_relaxed) &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"内存顺序示例 - Acquire: "</span> &lt;&lt; acquire_counter.load(std::memory_order_acquire) &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"内存顺序示例 - Release: "</span> &lt;&lt; release_counter.load(std::memory_order_release) &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 使用原子操作实现简单的锁</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::atomic&lt;<span class="text-purple-400">bool</span>&gt; lock_flag{<span class="text-purple-400">false</span>};<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">auto</span> lock_func = [&amp;lock_flag]() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">bool</span> expected = <span class="text-purple-400">false</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">while</span> (!lock_flag.compare_exchange_weak(expected, <span class="text-purple-400">true</span>)) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expected = <span class="text-purple-400">false</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::this_thread::sleep_for(std::chrono::microseconds(1));<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;};<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">auto</span> unlock_func = [&amp;lock_flag]() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock_flag.store(<span class="text-purple-400">false</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;};<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"原子锁示例 - 锁定/解锁操作演示完成"</span> &lt;&lt; std::endl;<br>
                        }<br>
                        <br>
                        <span class="text-purple-400">int</span> main() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;atomic_examples();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> 0;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 29. chrono时间库 -->
        <section id="section-29" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">29. chrono时间库</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - chrono时间库 (chrono Time Library)</h4>
                <p class="text-slate-300 mb-4">特点：提供高精度时间处理能力，包括duration、time_point等类型；支持各种时间单位的转换；提供时钟类型如steady_clock、system_clock等。注意事项：使用steady_clock可以获得单调递增的时间；duration支持各种时间单位的自动转换；适合需要精确时间测量的应用。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># chrono时间库的使用</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">#include &lt;iostream&gt;</span><br>
                        <span class="text-blue-300">#include &lt;chrono&gt;</span><br>
                        <span class="text-blue-300">#include &lt;thread&gt;</span><br>
                        <span class="text-blue-300">#include &lt;ctime&gt;</span><br>
                        <span class="text-blue-300">#include &lt;ratio&gt;</span><br>
                        <br>
                        <span class="text-purple-400">void</span> <span class="text-yellow-300">chrono_examples</span>() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"=== chrono时间库示例 ==="</span> &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 基本duration类型</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::duration&lt;<span class="text-purple-400">int</span>&gt; one_second(1);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::duration&lt;<span class="text-purple-400">double</span>, std::ratio&lt;1, 1000&gt;&gt; one_millisecond(1000.0);<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"1秒 = "</span> &lt;&lt; one_second.count() &lt;&lt; <span class="text-green-300">" 秒"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"1毫秒 = "</span> &lt;&lt; one_millisecond.count() &lt;&lt; <span class="text-green-300">" 毫秒"</span> &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 使用预定义的时间单位</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::seconds sec(5);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::milliseconds ms(5000);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::microseconds us(5000000);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::nanoseconds ns(5000000000);<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"5秒 = "</span> &lt;&lt; ms.count() &lt;&lt; <span class="text-green-300">" 毫秒"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"5秒 = "</span> &lt;&lt; us.count() &lt;&lt; <span class="text-green-300">" 微秒"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"5秒 = "</span> &lt;&lt; ns.count() &lt;&lt; <span class="text-green-300">" 纳秒"</span> &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 时间单位转换</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::duration&lt;<span class="text-purple-400">double</span>, std::ratio&lt;60&gt;&gt; one_minute(1.5);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::duration&lt;<span class="text-purple-400">double</span>&gt; in_seconds = one_minute;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"1.5分钟 = "</span> &lt;&lt; in_seconds.count() &lt;&lt; <span class="text-green-300">" 秒"</span> &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 使用time_point</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">auto</span> start = std::chrono::high_resolution_clock::now();<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 模拟一些工作</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::this_thread::sleep_for(std::chrono::milliseconds(100));<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">auto</span> end = std::chrono::high_resolution_clock::now();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::duration&lt;<span class="text-purple-400">double</span>, std::milli&gt; elapsed = end - start;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"执行时间: "</span> &lt;&lt; elapsed.count() &lt;&lt; <span class="text-green-300">" 毫秒"</span> &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 不同时钟类型</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">auto</span> system_time = std::chrono::system_clock::now();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">auto</span> steady_time = std::chrono::steady_clock::now();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">auto</span> high_res_time = std::chrono::high_resolution_clock::now();<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::time_t system_time_t = std::chrono::system_clock::to_time_t(system_time);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"系统时间: "</span> &lt;&lt; std::ctime(&amp;system_time_t);<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// duration的算术运算</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::seconds duration1(10);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::milliseconds duration2(5000);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::milliseconds total = duration1 + duration2;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"总时间: "</span> &lt;&lt; total.count() &lt;&lt; <span class="text-green-300">" 毫秒"</span> &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 比较duration</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">if</span> (duration1 &gt; duration2) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"duration1 大于 duration2"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;} <span class="text-purple-400">else</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"duration1 不大于 duration2"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 使用ratio进行自定义时间单位</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::duration&lt;<span class="text-purple-400">int</span>, std::ratio&lt;3600&gt;&gt; one_hour(1);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::duration&lt;<span class="text-purple-400">int</span>, std::ratio&lt;60&gt;&gt; two_minutes(2);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"1小时 = "</span> &lt;&lt; one_hour.count() &lt;&lt; <span class="text-green-300">" 秒"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"2分钟 = "</span> &lt;&lt; two_minutes.count() &lt;&lt; <span class="text-green-300">" 秒"</span> &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 精确计时示例</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"\n=== 精确计时示例 ==="</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">auto</span> precise_start = std::chrono::high_resolution_clock::now();<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 计算简单循环的执行时间</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">volatile</span> <span class="text-purple-400">int</span> sum = 0;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">for</span> (<span class="text-purple-400">int</span> i = 0; i &lt; 1000000; ++i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum += i;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">auto</span> precise_end = std::chrono::high_resolution_clock::now();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::duration&lt;<span class="text-purple-400">double</span>, std::nano&gt; precise_elapsed = precise_end - precise_start;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"循环执行时间: "</span> &lt;&lt; precise_elapsed.count() &lt;&lt; <span class="text-green-300">" 纳秒"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"循环执行时间: "</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(precise_elapsed).count() &lt;&lt; <span class="text-green-300">" 微秒"</span> &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 时间点计算</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::time_point&lt;std::chrono::system_clock&gt; now = std::chrono::system_clock::now();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::time_point&lt;std::chrono::system_clock&gt; one_hour_later = now + std::chrono::hours(1);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::time_point&lt;std::chrono::system_clock&gt; two_hours_earlier = now - std::chrono::hours(2);<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::time_t now_time = std::chrono::system_clock::to_time_t(now);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::time_t later_time = std::chrono::system_clock::to_time_t(one_hour_later);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"当前时间: "</span> &lt;&lt; std::ctime(&amp;now_time);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"一小时后: "</span> &lt;&lt; std::ctime(&amp;later_time);<br>
                        }<br>
                        <br>
                        <span class="text-purple-400">int</span> main() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;chrono_examples();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> 0;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 30. 随机数库 -->
        <section id="section-30" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">30. 随机数库</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 随机数库 (Random Number Library)</h4>
                <p class="text-slate-300 mb-4">特点：提供高质量的随机数生成器，包括线性同余、梅森旋转等算法；支持多种概率分布如均匀分布、正态分布等；比传统rand()函数更可靠。注意事项：选择合适的随机数引擎和分布；需要设置种子以获得不同的随机序列；注意线程安全问题。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 随机数库的使用</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">#include &lt;iostream&gt;</span><br>
                        <span class="text-blue-300">#include &lt;random&gt;</span><br>
                        <span class="text-blue-300">#include &lt;vector&gt;</span><br>
                        <span class="text-blue-300">#include &lt;map&gt;</span><br>
                        <span class="text-blue-300">#include &lt;chrono&gt;</span><br>
                        <br>
                        <span class="text-purple-400">void</span> <span class="text-yellow-300">random_examples</span>() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"=== 随机数库示例 ==="</span> &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 使用不同的随机数引擎</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::default_random_engine engine1;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::mt19937 engine2; <span class="text-blue-300">// 梅森旋转算法</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::ranlux24_base engine3; <span class="text-blue-300">// 高质量但较慢的引擎</span><br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 设置种子</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::random_device rd; <span class="text-blue-300">// 真随机数设备</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;engine1.seed(rd());<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;engine2.seed(std::chrono::high_resolution_clock::now().time_since_epoch().count());<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 均匀整数分布</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::uniform_int_distribution&lt;<span class="text-purple-400">int</span>&gt; uniform_dist(1, 100);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"均匀整数分布 (1-100): "</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">for</span> (<span class="text-purple-400">int</span> i = 0; i &lt; 5; ++i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; uniform_dist(engine1) &lt;&lt; <span class="text-green-300">" "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 均匀实数分布</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::uniform_real_distribution&lt;<span class="text-purple-400">double</span>&gt; real_dist(0.0, 1.0);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"均匀实数分布 (0.0-1.0): "</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">for</span> (<span class="text-purple-400">int</span> i = 0; i &lt; 5; ++i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; real_dist(engine2) &lt;&lt; <span class="text-green-300">" "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 正态分布</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::normal_distribution&lt;<span class="text-purple-400">double</span>&gt; normal_dist(0.0, 1.0); <span class="text-blue-300">// 均值0，标准差1</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"正态分布 (均值0，标准差1): "</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">for</span> (<span class="text-purple-400">int</span> i = 0; i &lt; 5; ++i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; normal_dist(engine1) &lt;&lt; <span class="text-green-300">" "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 伯努利分布</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::bernoulli_distribution bernoulli_dist(0.3); <span class="text-blue-300">// 30%概率为true</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"伯努利分布 (30%概率): "</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">for</span> (<span class="text-purple-400">int</span> i = 0; i &lt; 10; ++i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; (bernoulli_dist(engine2) ? <span class="text-green-300">"true"</span> : <span class="text-green-300">"false"</span>) &lt;&lt; <span class="text-green-300">" "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 二项分布</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::binomial_distribution&lt;<span class="text-purple-400">int</span>&gt; binomial_dist(10, 0.5); <span class="text-blue-300">// 10次试验，成功率0.5</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"二项分布 (10次试验，成功率0.5): "</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">for</span> (<span class="text-purple-400">int</span> i = 0; i &lt; 5; ++i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; binomial_dist(engine1) &lt;&lt; <span class="text-green-300">" "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 泊松分布</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::poisson_distribution&lt;<span class="text-purple-400">int</span>&gt; poisson_dist(2.5); <span class="text-blue-300">// 平均值2.5</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"泊松分布 (平均值2.5): "</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">for</span> (<span class="text-purple-400">int</span> i = 0; i &lt; 5; ++i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; poisson_dist(engine2) &lt;&lt; <span class="text-green-300">" "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 指数分布</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::exponential_distribution&lt;<span class="text-purple-400">double</span>&gt; exponential_dist(1.0);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"指数分布 (λ=1.0): "</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">for</span> (<span class="text-purple-400">int</span> i = 0; i &lt; 5; ++i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; exponential_dist(engine1) &lt;&lt; <span class="text-green-300">" "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 洗牌算法示例</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;<span class="text-purple-400">int</span>&gt; numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"原始数组: "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">for</span> (<span class="text-purple-400">int</span> n : numbers) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; n &lt;&lt; <span class="text-green-300">" "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::shuffle(numbers.begin(), numbers.end(), engine2);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"洗牌后数组: "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">for</span> (<span class="text-purple-400">int</span> n : numbers) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; n &lt;&lt; <span class="text-green-300">" "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 随机选择示例</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;std::string&gt; options = {<span class="text-green-300">"苹果"</span>, <span class="text-green-300">"香蕉"</span>, <span class="text-green-300">"橙子"</span>, <span class="text-green-300">"葡萄"</span>, <span class="text-green-300">"草莓"</span>};<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::uniform_int_distribution&lt;&span class="text-purple-400">int</span>&gt; option_dist(0, options.size() - 1);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"随机选择的水果: "</span> &lt;&lt; options[option_dist(engine1)] &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 模拟掷骰子</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::uniform_int_distribution&lt;<span class="text-purple-400">int</span>&gt; dice_dist(1, 6);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"掷骰子10次: "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">for</span> (<span class="text-purple-400">int</span> i = 0; i &lt; 10; ++i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; dice_dist(engine2) &lt;&lt; <span class="text-green-300">" "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">// 统计分布示例</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::map&lt;<span class="text-purple-400">int</span>, <span class="text-purple-400">int</span>&gt; counts;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::uniform_int_distribution&lt;<span class="text-purple-400">int</span>&gt; stats_dist(1, 6);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">for</span> (<span class="text-purple-400">int</span> i = 0; i &lt; 1000; ++i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counts[stats_dist(engine1)]++;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"1000次掷骰子统计: "</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">for</span> (<span class="text-purple-400">const</span> <span class="text-purple-400">auto</span>&amp; pair : counts) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"点数 "</span> &lt;&lt; pair.first &lt;&lt; <span class="text-green-300">": "</span> &lt;&lt; pair.second &lt;&lt; <span class="text-green-300">" 次"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        }<br>
                        <br>
                        <span class="text-purple-400">int</span> main() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;random_examples();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> 0;<br>
                        }
                    </div>
                </div>
            </div>
        </section>
    </div>
</div>
    </main>
    <script src="static/js/theme.js"></script>
</body>
</html>1, 2, 3, 4, 5};<br>
                        <span class="text-blue-300">MyClass</span> obj1(<span class="text-purple-400">std::move</span>(vec)); <span class="text-blue-300">// 触发移动构造</span><br>
                        <br>
                        <span class="text-purple-400">std::vector</span>&lt;<span class="text-purple-400">int</span>&gt; vec2 = {6, 7, 8, 9, 10};<br>
                        <span class="text-blue-300">MyClass</span> obj2(vec2);<br>
                        obj2 = <span class="text-blue-300">MyClass</span>(<span class="text-purple-400">std::move</span>(vec2)); <span class="text-blue-300">// 触发移动赋值</span><br>
                    </div>
                </div>
            </div>
        </section>
    </div>
</div>
    </main>
</body>
</html><span class="text-yellow-300">1</span>, <span class="text-yellow-300">2</span>, <span class="text-yellow-300">3</span>, <span class="text-yellow-300">4</span>, <span class="text-yellow-300">5</span>};<br>
                        vec.<span class="text-blue-300">push_back</span>(<span class="text-yellow-300">6</span>); <span class="text-blue-300">// 添加元素</span><br>
                        <span class="text-purple-400">int</span> size = vec.<span class="text-blue-300">size</span>(); <span class="text-blue-300">// 获取大小</span><br>
                        <br>
                        <span class="text-blue-300">// std::string</span><br>
                        <span class="text-purple-400">std::string</span> str = <span class="text-green-300">"Hello, C++"</span>;<br>
                        str += <span class="text-green-300">"!"</span>; <span class="text-blue-300">// 字符串连接</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- 6. 指针与引用 -->
        <section id="section-6" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">6. 指针与引用</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 指针、引用和智能指针</h4>
                <p class="text-slate-300 mb-4">特点：支持传统指针和引用，C++11引入了智能指针管理内存。注意事项：优先使用智能指针，避免内存泄漏和悬空指针问题。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 指针与引用</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 指针</span><br>
                        <span class="text-purple-400">int</span> value = <span class="text-yellow-300">42</span>;<br>
                        <span class="text-purple-400">int</span>* ptr = &amp;value; <span class="text-blue-300">// 指向value的指针</span><br>
                        <span class="text-purple-400">int</span> dereferenced = *ptr; <span class="text-blue-300">// 解引用</span><br>
                        <br>
                        <span class="text-blue-300">// 引用</span><br>
                        <span class="text-purple-400">int</span>&amp; ref = value; <span class="text-blue-300">// value的引用</span><br>
                        ref = <span class="text-yellow-300">100</span>; <span class="text-blue-300">// value现在是100</span><br>
                        <br>
                        <span class="text-blue-300">// 智能指针 (C++11)</span><br>
                        <span class="text-purple-400">std::unique_ptr</span>&lt;<span class="text-purple-400">int</span>&gt; uniquePtr = <span class="text-blue-300">std::make_unique</span>&lt;<span class="text-purple-400">int</span>&gt;(<span class="text-yellow-300">42</span>);<br>
                        <span class="text-purple-400">std::shared_ptr</span>&lt;<span class="text-purple-400">int</span>&gt; sharedPtr1 = <span class="text-blue-300">std::make_shared</span>&lt;<span class="text-purple-400">int</span>&gt;(<span class="text-yellow-300">42</span>);<br>
                        <span class="text-purple-400">std::shared_ptr</span>&lt;<span class="text-purple-400">int</span>&gt; sharedPtr2 = sharedPtr1; <span class="text-blue-300">// 引用计数增加</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- 7. 类与对象 -->
        <section id="section-7" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">7. 类与对象</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 类定义、构造函数和析构函数</h4>
                <p class="text-slate-300 mb-4">特点：支持封装、继承、多态等面向对象特性，C++11引入了默认函数、删除函数等。注意事项：合理使用构造函数和析构函数管理资源，遵循RAII原则。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 类与对象</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 类定义</span><br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">Person</span> {<br>
                        <span class="text-purple-400">private</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">std::string</span> name;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">int</span> age;<br>
                        <br>
                        <span class="text-purple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">Person</span>(<span class="text-purple-400">const</span> <span class="text-purple-400">std::string</span>& n, <span class="text-purple-400">int</span> a) : name(n), age(a) {} <span class="text-blue-300">// 构造函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">~Person</span>() { <span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"Person destroyed"</span> &lt;&lt; <span class="text-green-300">std::endl</span>; } <span class="text-blue-300">// 析构函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">const</span> <span class="text-purple-400">std::string</span>& <span class="text-blue-300">getName</span>() <span class="text-purple-400">const</span> { <span class="text-purple-400">return</span> name; }<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">int</span> <span class="text-blue-300">getAge</span>() <span class="text-purple-400">const</span> { <span class="text-purple-400">return</span> age; }<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">void</span> <span class="text-blue-300">setAge</span>(<span class="text-purple-400">int</span> newAge) { age = newAge; }<br>
                        };<br>
                        <br>
                        <span class="text-blue-300">// 对象创建和使用</span><br>
                        <span class="text-blue-300">Person</span> person(<span class="text-green-300">"Alice"</span>, <span class="text-yellow-300">30</span>);<br>
                        <span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"Name: "</span> &lt;&lt; person.<span class="text-blue-300">getName</span>() &lt;&lt; <span class="text-green-300">", Age: "</span> &lt;&lt; person.<span class="text-blue-300">getAge</span>() &lt;&lt; <span class="text-green-300">std::endl</span>;
                    </div>
                </div>
            </div>
        </section>

        <!-- 8. 继承与多态 -->
        <section id="section-8" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">8. 继承与多态</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 继承、虚函数和多态</h4>
                <p class="text-slate-300 mb-4">特点：支持单继承和多继承，虚函数实现动态多态，C++11引入了override和final关键字。注意事项：使用override关键字确保函数重写，合理设计继承层次结构。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 继承与多态</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 基类</span><br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">Animal</span> {<br>
                        <span class="text-purple-400">protected</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">std::string</span> name;<br>
                        <br>
                        <span class="text-purple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">Animal</span>(<span class="text-purple-400">const</span> <span class="text-purple-400">std::string</span>& n) : name(n) {}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">virtual</span> <span class="text-blue-300">~Animal</span>() = <span class="text-purple-400">default</span>; <span class="text-blue-300">// 虚析构函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">virtual</span> <span class="text-purple-400">void</span> <span class="text-blue-300">speak</span>() <span class="text-purple-400">const</span> { <span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"Animal speaks"</span> &lt;&lt; <span class="text-green-300">std::endl</span>; }<br>
                        };<br>
                        <br>
                        <span class="text-blue-300">// 派生类</span><br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">Dog</span> : <span class="text-purple-400">public</span> <span class="text-blue-300">Animal</span> {<br>
                        <span class="text-purple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">Dog</span>(<span class="text-purple-400">const</span> <span class="text-purple-400">std::string</span>& n) : <span class="text-blue-300">Animal</span>(n) {}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">void</span> <span class="text-blue-300">speak</span>() <span class="text-purple-400">const</span> <span class="text-purple-400">override</span> { <span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"Woof!"</span> &lt;&lt; <span class="text-green-300">std::endl</span>; } <span class="text-blue-300">// C++11 override</span><br>
                        };<br>
                        <br>
                        <span class="text-blue-300">// 多态使用</span><br>
                        <span class="text-blue-300">Animal</span>* animal = <span class="text-purple-400">new</span> <span class="text-blue-300">Dog</span>(<span class="text-green-300">"Buddy"</span>);<br>
                        animal-&gt;<span class="text-blue-300">speak</span>(); <span class="text-blue-300">// 输出 "Woof!"</span><br>
                        <span class="text-purple-400">delete</span> animal;
                    </div>
                </div>
            </div>
        </section>

        <!-- 9. 模板 -->
        <section id="section-9" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">9. 模板</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 函数模板和类模板</h4>
                <p class="text-slate-300 mb-4">特点：支持函数模板和类模板，实现泛型编程，C++11引入了可变参数模板。注意事项：模板在编译时生成代码，可能增加编译时间和可执行文件大小。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 模板</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 函数模板</span><br>
                        <span class="text-purple-400">template</span>&lt;<span class="text-purple-400">typename</span> T&gt;<br>
                        T <span class="text-blue-300">max</span>(T a, T b) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> (a &gt; b) ? a : b;<br>
                        }<br>
                        <br>
                        <span class="text-blue-300">// 使用函数模板</span><br>
                        <span class="text-purple-400">int</span> intMax = <span class="text-blue-300">max</span>(<span class="text-yellow-300">10</span>, <span class="text-yellow-300">20</span>);<br>
                        <span class="text-purple-400">double</span> doubleMax = <span class="text-blue-300">max</span>(<span class="text-yellow-300">3.14</span>, <span class="text-yellow-300">2.71</span>);<br>
                        <br>
                        <span class="text-blue-300">// 类模板</span><br>
                        <span class="text-purple-400">template</span>&lt;<span class="text-purple-400">typename</span> T&gt;<br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">Container</span> {<br>
                        <span class="text-purple-400">private</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;T value;<br>
                        <br>
                        <span class="text-purple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">Container</span>(T v) : value(v) {}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;T <span class="text-blue-300">getValue</span>() <span class="text-purple-400">const</span> { <span class="text-purple-400">return</span> value; }<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">void</span> <span class="text-blue-300">setValue</span>(T v) { value = v; }<br>
                        };
                    </div>
                </div>
            </div>
        </section>

        <!-- 10. 异常处理 -->
        <section id="section-10" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">10. 异常处理</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 异常处理机制</h4>
                <p class="text-slate-300 mb-4">特点：支持try-catch-finally模式，可以抛出任意类型的异常，C++11增强了异常安全性。注意事项：异常处理会影响性能，不应作为常规流程控制使用。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 异常处理</div>
                    <div class="text-sm leading-6">
                        <span class="text-purple-400">try</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">std::vector</span>&lt;<span class="text-purple-400">int</span>&gt; vec(<span class="text-yellow-300">5</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-green-300">std::cout</span> &lt;&lt; vec.<span class="text-blue-300">at</span>(<span class="text-yellow-300">10</span>) &lt;&lt; <span class="text-green-300">std::endl</span>; <span class="text-blue-300">// 抛出 std::out_of_range</span><br>
                        } <span class="text-purple-400">catch</span> (<span class="text-purple-400">const</span> <span class="text-blue-300">std::out_of_range</span>& e) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"Out of range error: "</span> &lt;&lt; e.<span class="text-blue-300">what</span>() &lt;&lt; <span class="text-green-300">std::endl</span>;<br>
                        } <span class="text-purple-400">catch</span> (...) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"Unknown exception"</span> &lt;&lt; <span class="text-green-300">std::endl</span>;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 11. 面向对象编程 -->
        <section id="section-11" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">11. 面向对象编程</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 面向对象编程特性</h4>
                <p class="text-slate-300 mb-4">特点：封装、继承、多态三大特性，支持抽象类和接口设计。注意事项：合理使用访问控制符，遵循面向对象设计原则。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 面向对象编程</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 抽象类</span><br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">Shape</span> {<br>
                        <span class="text-purple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">virtual</span> <span class="text-purple-400">double</span> <span class="text-blue-300">area</span>() <span class="text-purple-400">const</span> = <span class="text-yellow-300">0</span>; <span class="text-blue-300">// 纯虚函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">virtual</span> <span class="text-purple-400">void</span> <span class="text-blue-300">draw</span>() <span class="text-purple-400">const</span> = <span class="text-yellow-300">0</span>; <span class="text-blue-300">// 纯虚函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">virtual</span> <span class="text-blue-300">~Shape</span>() = <span class="text-purple-400">default</span>;<br>
                        };<br>
                        <br>
                        <span class="text-blue-300">// 具体实现类</span><br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">Circle</span> : <span class="text-purple-400">public</span> <span class="text-blue-300">Shape</span> {<br>
                        <span class="text-purple-400">private</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">double</span> radius;<br>
                        <br>
                        <span class="text-purple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">Circle</span>(<span class="text-purple-400">double</span> r) : radius(r) {}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">double</span> <span class="text-blue-300">area</span>() <span class="text-purple-400">const</span> <span class="text-purple-400">override</span> { <span class="text-purple-400">return</span> <span class="text-yellow-300">3.14159</span> * radius * radius; }<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">void</span> <span class="text-blue-300">draw</span>() <span class="text-purple-400">const</span> <span class="text-purple-400">override</span> { <span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"Drawing a circle"</span> &lt;&lt; <span class="text-green-300">std::endl</span>; }<br>
                        };
                    </div>
                </div>
            </div>
        </section>

        <!-- 12. 继承和多态 -->
        <section id="section-12" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">12. 继承和多态</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 复杂继承关系和多态实现</h4>
                <p class="text-slate-300 mb-4">特点：支持多重继承、虚继承、虚函数等高级特性，C++11引入了override和final关键字。注意事项：设计继承关系时要考虑菱形继承问题，合理使用虚继承。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 继承和多态</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 虚继承示例</span><br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">Vehicle</span> {<br>
                        <span class="text-purple-400">protected</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">std::string</span> brand;<br>
                        <br>
                        <span class="text-purple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">Vehicle</span>(<span class="text-purple-400">const</span> <span class="text-purple-400">std::string</span>& b) : brand(b) {}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">virtual</span> <span class="text-purple-400">void</span> <span class="text-blue-300">start</span>() = <span class="text-yellow-300">0</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">virtual</span> <span class="text-blue-300">~Vehicle</span>() = <span class="text-purple-400">default</span>;<br>
                        };<br>
                        <br>
                        <span class="text-blue-300">// 虚继承</span><br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">Car</span> : <span class="text-purple-400">virtual</span> <span class="text-purple-400">public</span> <span class="text-blue-300">Vehicle</span> {<br>
                        <span class="text-purple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">Car</span>(<span class="text-purple-400">const</span> <span class="text-purple-400">std::string</span>& b) : <span class="text-blue-300">Vehicle</span>(b) {}<br>
                        };<br>
                        <br>
                        <span class="text-blue-300">// 多重继承</span><br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">ElectricCar</span> : <span class="text-purple-400">public</span> <span class="text-blue-300">Car</span> {<br>
                        <span class="text-purple-400">private</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">double</span> batteryLevel;<br>
                        <br>
                        <span class="text-purple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">ElectricCar</span>(<span class="text-purple-400">const</span> <span class="text-purple-400">std::string</span>& b, <span class="text-purple-400">double</span> level) : <span class="text-blue-300">Car</span>(b), batteryLevel(level) {}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">void</span> <span class="text-blue-300">start</span>() <span class="text-purple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"Electric car starting silently"</span> &lt;&lt; <span class="text-green-300">std::endl</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        };
                    </div>
                </div>
            </div>
        </section>

        <!-- 13. 异常处理 -->
        <section id="section-13" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">13. 异常处理</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 高级异常处理和异常安全</h4>
                <p class="text-slate-300 mb-4">特点：支持异常规范、noexcept说明符、异常安全保证等特性，C++11增强了异常安全性。注意事项：异常安全分为基本保证、强保证和不抛异常保证三个级别。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 高级异常处理</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 自定义异常类</span><br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">CustomException</span> : <span class="text-purple-400">public</span> <span class="text-blue-300">std::exception</span> {<br>
                        <span class="text-purple-400">private</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">std::string</span> message;<br>
                        <br>
                        <span class="text-purple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">CustomException</span>(<span class="text-purple-400">const</span> <span class="text-purple-400">std::string</span>& msg) : message(msg) {}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">const</span> <span class="text-purple-400">char</span>* <span class="text-blue-300">what</span>() <span class="text-purple-400">const</span> <span class="text-purple-400">noexcept</span> <span class="text-purple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> message.<span class="text-blue-300">c_str</span>();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        };<br>
                        <br>
                        <span class="text-blue-300">// 使用noexcept (C++11)</span><br>
                        <span class="text-purple-400">void</span> <span class="text-blue-300">functionThatDoesNotThrow</span>() <span class="text-purple-400">noexcept</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"This function does not throw exceptions"</span> &lt;&lt; <span class="text-green-300">std::endl</span>;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 14. 智能指针 -->
        <section id="section-14" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">14. 智能指针</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 智能指针管理内存</h4>
                <p class="text-slate-300 mb-4">特点：C++11引入了unique_ptr、shared_ptr、weak_ptr等智能指针，实现自动内存管理。注意事项：优先使用RAII原则和智能指针，避免手动内存管理。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 智能指针</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// unique_ptr - 独占所有权</span><br>
                        <span class="text-purple-400">auto</span> uniquePtr = <span class="text-blue-300">std::make_unique</span>&lt;<span class="text-purple-400">int</span>&gt;(<span class="text-yellow-300">42</span>);<br>
                        <span class="text-purple-400">int</span> value = *uniquePtr; <span class="text-blue-300">// 访问值</span><br>
                        <br>
                        <span class="text-blue-300">// shared_ptr - 共享所有权</span><br>
                        <span class="text-purple-400">auto</span> sharedPtr1 = <span class="text-blue-300">std::make_shared</span>&lt;<span class="text-purple-400">int</span>&gt;(<span class="text-yellow-300">42</span>);<br>
                        <span class="text-purple-400">auto</span> sharedPtr2 = sharedPtr1; <span class="text-blue-300">// 引用计数增加</span><br>
                        <span class="text-purple-400">int</span> count = sharedPtr1.<span class="text-blue-300">use_count</span>(); <span class="text-blue-300">// 获取引用计数</span><br>
                        <br>
                        <span class="text-blue-300">// weak_ptr - 避免循环引用</span><br>
                        <span class="text-purple-400">std::weak_ptr</span>&lt;<span class="text-purple-400">int</span>&gt; weakPtr = sharedPtr1;<br>
                        <span class="text-purple-400">if</span> (<span class="text-purple-400">auto</span> lockedPtr = weakPtr.<span class="text-blue-300">lock</span>()) { <span class="text-blue-300">// 检查对象是否仍然存在</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"Value: "</span> &lt;&lt; *lockedPtr &lt;&lt; <span class="text-green-300">std::endl</span>;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 15. 文件操作 -->
        <section id="section-15" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">15. 文件操作</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 文件输入输出操作</h4>
                <p class="text-slate-300 mb-4">特点：支持文本文件和二进制文件操作，提供ifstream、ofstream、fstream等流类。注意事项：操作完成后要检查文件状态并关闭文件。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 文件操作</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 写入文件</span><br>
                        <span class="text-purple-400">std::ofstream</span> outFile(<span class="text-green-300">"example.txt"</span>);<br>
                        <span class="text-purple-400">if</span> (outFile.<span class="text-blue-300">is_open</span>()) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;outFile &lt;&lt; <span class="text-green-300">"Hello, C++ File!"</span> &lt;&lt; <span class="text-green-300">std::endl</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;outFile &lt;&lt; <span class="text-yellow-300">42</span> &lt;&lt; <span class="text-green-300">" "</span> &lt;&lt; <span class="text-yellow-300">3.14</span> &lt;&lt; <span class="text-green-300">std::endl</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;outFile.<span class="text-blue-300">close</span>();<br>
                        }<br>
                        <br>
                        <span class="text-blue-300">// 读取文件</span><br>
                        <span class="text-purple-400">std::ifstream</span> inFile(<span class="text-green-300">"example.txt"</span>);<br>
                        <span class="text-purple-400">if</span> (inFile.<span class="text-blue-300">is_open</span>()) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">std::string</span> line;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">while</span> (<span class="text-purple-400">std::getline</span>(inFile, line)) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="text-green-300">std::cout</span> &lt;&lt; line &lt;&lt; <span class="text-green-300">std::endl</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;inFile.<span class="text-blue-300">close</span>();<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 16. Lambda表达式 -->
        <section id="section-16" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">16. Lambda表达式</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - Lambda表达式和函数式编程</h4>
                <p class="text-slate-300 mb-4">特点：C++11引入了Lambda表达式，支持闭包、捕获列表等特性。注意事项：注意捕获方式(值捕获、引用捕获)对Lambda生命周期的影响。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># Lambda表达式</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 基本Lambda表达式</span><br>
                        <span class="text-purple-400">auto</span> add = [](<span class="text-purple-400">int</span> a, <span class="text-purple-400">int</span> b) { <span class="text-purple-400">return</span> a + b; };<br>
                        <span class="text-purple-400">int</span> result = <span class="text-blue-300">add</span>(<span class="text-yellow-300">5</span>, <span class="text-yellow-300">3</span>); <span class="text-blue-300">// 结果为 8</span><br>
                        <br>
                        <span class="text-blue-300">// 值捕获</span><br>
                        <span class="text-purple-400">int</span> multiplier = <span class="text-yellow-300">10</span>;<br>
                        <span class="text-purple-400">auto</span> multiplyByTen = [multiplier](<span class="text-purple-400">int</span> x) { <span class="text-purple-400">return</span> x * multiplier; };<br>
                        <br>
                        <span class="text-blue-300">// 引用捕获</span><br>
                        <span class="text-purple-400">auto</span> multiplyByRef = [&amp;multiplier](<span class="text-purple-400">int</span> x) { <span class="text-purple-400">return</span> x * multiplier; };<br>
                        <br>
                        <span class="text-blue-300">// 使用Lambda配合STL算法</span><br>
                        <span class="text-purple-400">std::vector</span>&lt;<span class="text-purple-400">int</span>&gt; numbers = {<span class="text-yellow-300">1</span>, <span class="text-yellow-300">2</span>, <span class="text-yellow-300">3</span>, <span class="text-yellow-300">4</span>, <span class="text-yellow-300">5</span>};<br>
                        <span class="text-purple-400">std::sort</span>(numbers.<span class="text-blue-300">begin</span>(), numbers.<span class="text-blue-300">end</span>(), [](<span class="text-purple-400">int</span> a, <span class="text-purple-400">int</span> b) { <span class="text-purple-400">return</span> a &gt; b; }); <span class="text-blue-300">// 降序排序</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- 17. 移动语义 -->
        <section id="section-17" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">17. 移动语义</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 移动语义和右值引用</h4>
                <p class="text-slate-300 mb-4">特点：C++11引入了移动语义，通过右值引用提高性能，避免不必要的拷贝。注意事项：合理使用std::move，理解左值和右值的区别。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 移动语义</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 移动构造函数示例</span><br>
                        <span class="text-purple-400">class</span> <span class="text-blue-300">MyClass</span> {<br>
                        <span class="text-purple-400">private</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">std::vector</span>&lt;<span class="text-purple-400">int</span>&gt; data;<br>
                        <br>
                        <span class="text-purple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">MyClass</span>(<span class="text-purple-400">std::vector</span>&lt;<span class="text-purple-400">int</span>&gt; vec) : data(<span class="text-purple-400">std::move</span>(vec)) {} <span class="text-blue-300">// 移动构造</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">MyClass</span>(<span class="text-blue-300">MyClass</span>&& other) <span class="text-purple-400">noexcept</span> : data(<span class="text-purple-400">std::move</span>(other.data)) {} <span class="text-blue-300">// 移动构造函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">MyClass</span>& <span class="text-blue-300">operator</span>= (<span class="text-blue-300">MyClass</span>&& other) <span class="text-purple-400">noexcept</span> { <span class="text-green-300">// 移动赋值</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">if</span> (<span class="text-purple-400">this</span> != &amp;other) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data = <span class="text-purple-400">std::move</span>(other.data);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> *<span class="text-purple-400">this</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        };<br>
                        <br>
                        <span class="text-blue-300">// 使用移动语义</span><br>
                        <span class="text-purple-400">std::vector</span>&lt;<span class="text-purple-400">int</span>&gt; vec = {1, 2, 3, 4, 5};<br>
                        <span class="text-blue-300">MyClass</span> obj1(<span class="text-purple-400">std::move</span>(vec)); <span class="text-blue-300">// 触发移动构造</span><br>
                        <br>
                        <span class="text-purple-400">std::vector</span>&lt;<span class="text-purple-400">int</span>&gt; vec2 = {6, 7, 8, 9, 10};<br>
                        <span class="text-blue-300">MyClass</span> obj2(vec2);<br>
                        obj2 = <span class="text-blue-300">MyClass</span>(<span class="text-purple-400">std::move</span>(vec2)); <span class="text-blue-300">// 触发移动赋值</span><br>
                    </div>
                </div>
            </div>
        </section>
    </div>
</div>
    </main>
    <script src="static/js/theme.js"></script>
</body>
</html>