<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C++ 语言教程</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .gradient-text {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            color: transparent;
        }
        
        .code-font {
            font-family: 'Monaco', 'Consolas', 'Courier New', monospace;
        }
        
        .syntax-card {
            background: rgba(30, 41, 59, 0.8);
            border: 1px solid rgba(148, 163, 184, 0.3);
        }
        
        body {
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
        }
    </style>
</head>
<body class="min-h-screen">
    <main class="container mx-auto px-4 py-8 max-w-6xl">
          <div class="flex flex-col lg:flex-row gap-8">
              <div class="lg:w-1/4">
                  <div class="sticky top-4 bg-slate-900 rounded-xl p-6 shadow-lg max-h-[calc(100vh-2rem)] overflow-y-auto">
                      <h3 class="text-lg font-bold text-purple-400 mb-4">章节导航</h3>
                      <nav class="space-y-2">
                          <a href="#section-1" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">1. 变量声明与初始化</a>
                          <a href="#section-2" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">2. 基本数据类型</a>
                          <a href="#section-3" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">3. 控制流语句</a>
                          <a href="#section-4" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">4. 函数定义</a>
                          <a href="#section-5" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">5. 数组与容器</a>
                          <a href="#section-6" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">6. 指针与引用</a>
                          <a href="#section-7" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">7. 类与对象</a>
                          <a href="#section-8" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">8. 继承与多态</a>
                          <a href="#section-9" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">9. 模板</a>
                          <a href="#section-10" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">10. 异常处理</a>
                          <a href="#section-11" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">11. 面向对象编程</a>
                          <a href="#section-12" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">12. 继承和多态</a>
                          <a href="#section-13" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">13. 异常处理</a>
                          <a href="#section-14" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">14. 智能指针</a>
                          <a href="#section-15" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">15. 文件操作</a>
                          <a href="#section-16" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">16. Lambda表达式</a>
                          <a href="#section-17" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">17. 移动语义</a>
                          <a href="#section-18" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">18. 基于范围的for循环</a>
                          <a href="#section-19" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">19. nullptr关键字</a>
                          <a href="#section-20" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">20. 强类型枚举</a>
                          <a href="#section-21" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">21. 可变参数模板</a>
                          <a href="#section-22" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">22. 线程库</a>
                          <a href="#section-23" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">23. 正则表达式库</a>
                          <a href="#section-24" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">24. std::function和std::bind</a>
                          <a href="#section-25" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">25. 新的字符串字面量</a>
                          <a href="#section-26" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">26. 委托构造函数和继承构造函数</a>
                          <a href="#section-27" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">27. final/override控制</a>
                          <a href="#section-28" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">28. 原子操作</a>
                          <a href="#section-29" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">29. chrono时间库</a>
                          <a href="#section-30" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">30. 随机数库</a>
                          <a href="#section-31" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">31. 新的算法和容器</a>
                          <a href="#section-32" class="block py-2 px-3 rounded-lg text-slate-300 hover:bg-purple-900 hover:text-purple-300 transition-colors duration-200">32. static_assert和类型特质</a>
                      </nav>
                  </div>
              </div>
              <div class="lg:w-3/4">
                  <!-- 1. 变量声明与初始化 -->
                  <section id="section-1" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">1. 变量声明与初始化</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 变量声明、初始化和类型推导</h4>
                <p class="text-slate-300 mb-4">特点：支持多种数据类型，支持自动类型推导(auto)，支持统一初始化语法。注意事项：C++11引入了统一初始化语法，避免窄化转换，提高安全性。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 基本变量声明</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 传统声明</span><br>
                        <span class="text-purple-400">int</span> age = <span class="text-yellow-300">25</span>;<br>
                        <span class="text-purple-400">double</span> price = <span class="text-yellow-300">19.99</span>;<br>
                        <span class="text-purple-400">char</span> grade = <span class="text-green-300">'A'</span>;<br>
                        <span class="text-purple-400">bool</span> isActive = <span class="text-green-300">true</span>;<br>
                        <br>
                        <span class="text-blue-300">// C++11 统一初始化语法</span><br>
                        <span class="text-purple-400">int</span> x{<span class="text-yellow-300">10</span>};<br>
                        <span class="text-purple-400">double</span> y{<span class="text-yellow-300">3.14</span>};<br>
                        <span class="text-purple-400">std::string</span> name{<span class="text-green-300">"Hello"</span>};<br>
                        <br>
                        <span class="text-blue-300">// 类型推导</span><br>
                        <span class="text-purple-400">auto</span> num = <span class="text-yellow-300">42</span>; <span class="text-blue-300">// 推导为 int</span><br>
                        <span class="text-purple-400">auto</span> pi = <span class="text-yellow-300">3.14159</span>; <span class="text-blue-300">// 推导为 double</span><br>
                        <span class="text-purple-400">auto</span> flag = <span class="text-green-300">false</span>; <span class="text-blue-300">// 推导为 bool</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- 2. 基本数据类型 -->
        <section id="section-2" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">2. 基本数据类型</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 基本数据类型和大小</h4>
                <p class="text-slate-300 mb-4">特点：包括整型、浮点型、字符型、布尔型等，C++11引入了long long等扩展类型。注意事项：不同类型占用内存大小可能因平台而异，使用sizeof运算符可获取类型大小。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 基本数据类型</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 整型</span><br>
                        <span class="text-purple-400">bool</span> b = <span class="text-green-300">true</span>; <span class="text-blue-300">// 1 字节</span><br>
                        <span class="text-purple-400">char</span> c = <span class="text-green-300">'A'</span>; <span class="text-blue-300">// 1 字节</span><br>
                        <span class="text-purple-400">int</span> i = <span class="text-yellow-300">42</span>; <span class="text-blue-300">// 通常 4 字节</span><br>
                        <span class="text-purple-400">long</span> l = <span class="text-yellow-300">1000000L</span>; <span class="text-blue-300">// 通常 4 或 8 字节</span><br>
                        <span class="text-purple-400">long</span> <span class="text-purple-400">long</span> ll = <span class="text-yellow-300">10000000000LL</span>; <span class="text-blue-300">// 8 字节 (C++11)</span><br>
                        <br>
                        <span class="text-blue-300">// 浮点型</span><br>
                        <span class="text-purple-400">float</span> f = <span class="text-yellow-300">3.14f</span>; <span class="text-blue-300">// 4 字节</span><br>
                        <span class="text-purple-400">double</span> d = <span class="text-yellow-300">3.14159</span>; <span class="text-blue-300">// 8 字节</span><br>
                        <span class="text-purple-400">long</span> <span class="text-purple-400">double</span> ld = <span class="text-yellow-300">3.141592653589793L</span>; <span class="text-blue-300">// 通常 10 或 16 字节</span><br>
                        <br>
                        <span class="text-blue-300">// 类型大小</span><br>
                        <span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"sizeof(int): "</span> &lt;&lt; <span class="text-purple-400">sizeof</span>(<span class="text-purple-400">int</span>) &lt;&lt; <span class="text-green-300">std::endl</span>;
                    </div>
                </div>
            </div>
        </section>

        <!-- 3. 控制流语句 -->
        <section id="section-3" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">3. 控制流语句</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 条件语句、循环语句和范围for循环</h4>
                <p class="text-slate-300 mb-4">特点：支持if/else、switch、for、while、do-while等传统控制流，C++11新增范围for循环。注意事项：使用范围for循环遍历容器更安全便捷，避免越界问题。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 控制流语句</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// if-else 语句</span><br>
                        <span class="text-purple-400">int</span> score = <span class="text-yellow-300">85</span>;<br>
                        <span class="text-purple-400">if</span> (score &gt;= <span class="text-yellow-300">90</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"优秀"</span> &lt;&lt; <span class="text-green-300">std::endl</span>;<br>
                        } <span class="text-purple-400">else</span> <span class="text-purple-400">if</span> (score &gt;= <span class="text-yellow-300">80</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"良好"</span> &lt;&lt; <span class="text-green-300">std::endl</span>;<br>
                        } <span class="text-purple-400">else</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">"需努力"</span> &lt;&lt; <span class="text-green-300">std::endl</span>;<br>
                        }<br>
                        <br>
                        <span class="text-blue-300">// 范围 for 循环 (C++11)</span><br>
                        <span class="text-purple-400">std::vector</span>&lt;<span class="text-purple-400">int</span>&gt; numbers = {<span class="text-yellow-300">1</span>, <span class="text-yellow-300">2</span>, <span class="text-yellow-300">3</span>, <span class="text-yellow-300">4</span>, <span class="text-yellow-300">5</span>};<br>
                        <span class="text-purple-400">for</span> (<span class="text-purple-400">const</span> <span class="text-purple-400">auto</span>& element : numbers) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-green-300">std::cout</span> &lt;&lt; element &lt;&lt; <span class="text-green-300">" "</span>;<br>
                        }<br>
                        <span class="text-green-300">std::cout</span> &lt;&lt; <span class="text-green-300">std::endl</span>;
                    </div>
                </div>
            </div>
        </section>

        <!-- 4. 函数定义 -->
        <section id="section-4" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">4. 函数定义</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 函数定义、默认参数、函数重载和Lambda表达式</h4>
                <p class="text-slate-300 mb-4">特点：支持函数重载、默认参数、Lambda表达式等特性。注意事项：C++11引入了Lambda表达式，提供了更灵活的函数式编程能力。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 函数定义</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 基本函数定义</span><br>
                        <span class="text-purple-400">int</span> <span class="text-blue-300">add</span>(<span class="text-purple-400">int</span> a, <span class="text-purple-400">int</span> b) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> a + b;<br>
                        }<br>
                        <br>
                        <span class="text-blue-300">// 带默认参数的函数</span><br>
                        <span class="text-purple-400">double</span> <span class="text-blue-300">calculateArea</span>(<span class="text-purple-400">double</span> radius, <span class="text-purple-400">double</span> pi = <span class="text-yellow-300">3.14159</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> pi * radius * radius;<br>
                        }<br>
                        <br>
                        <span class="text-blue-300">// 函数重载</span><br>
                        <span class="text-purple-400">int</span> <span class="text-blue-300">max</span>(<span class="text-purple-400">int</span> a, <span class="text-purple-400">int</span> b) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> (a &gt; b) ? a : b;<br>
                        }<br>
                        <span class="text-purple-400">double</span> <span class="text-blue-300">max</span>(<span class="text-purple-400">double</span> a, <span class="text-purple-400">double</span> b) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-purple-400">return</span> (a &gt; b) ? a : b;<br>
                        }<br>
                        <br>
                        <span class="text-blue-300">// Lambda 表达式 (C++11)</span><br>
                        <span class="text-purple-400">auto</span> multiply = [](<span class="text-purple-400">int</span> x, <span class="text-purple-400">int</span> y) { <span class="text-purple-400">return</span> x * y; };<br>
                        <span class="text-purple-400">int</span> result = <span class="text-blue-300">multiply</span>(<span class="text-yellow-300">5</span>, <span class="text-yellow-300">3</span>); <span class="text-blue-300">// 结果为 15</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- 5. 数组与容器 -->
        <section id="section-5" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">5. 数组与容器</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 传统数组、std::array和STL容器</h4>
                <p class="text-slate-300 mb-4">特点：支持传统C风格数组，C++11引入了std::array，STL提供了丰富的容器。注意事项：推荐使用STL容器，它们更安全且功能更强大。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 数组与容器</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 传统数组</span><br>
                        <span class="text-purple-400">int</span> arr[<span class="text-yellow-300">5</span>] = {<span class="text-yellow-300">1</span>, <span class="text-yellow-300">2</span>, <span class="text-yellow-300">3</span>, <span class="text-yellow-300">4</span>, <span class="text-yellow-300">5</span>};<br>
                        <br>
                        <span class="text-blue-300">// std::array (C++11)</span><br>
                        <span class="text-purple-400">std::array</span>&lt;<span class="text-purple-400">int</span>, <span class="text-yellow-300">5</span>&gt; cppArray = {<span class="text-yellow-300">1</span>, <span class="text-yellow-300">2</span>, <span class="text-yellow-300">3</span>, <span class="text-yellow-300">4</span>, <span class="text-yellow-300">5</span>};<br>
                        <br>
                        <span class="text-blue-300">// std::vector</span><br>
                        <span class="text-purple-400">std::vector</span>&lt;<span class="text-purple-400">int</span>&gt; vec = {1, 2, 3, 4, 5};<br>
                        <span class="text-blue-300">MyClass</span> obj1(<span class="text-purple-400">std::move</span>(vec)); <span class="text-blue-300">// 触发移动构造</span><br>
                        <br>
                        <span class="text-purple-400">std::vector</span>&lt;<span class="text-purple-400">int</span>&gt; vec2 = {6, 7, 8, 9, 10};<br>
                        <span class="text-blue-300">MyClass</span> obj2(vec2);<br>
                        obj2 = <span class="text-blue-300">MyClass</span>(<span class="text-purple-400">std::move</span>(vec2)); <span class="text-blue-300">// 触发移动赋值</span><br>
                    </div>
                </div>
            </div>
        </section>

        <!-- 6. 指针与引用 -->
        <section id="section-6" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">6. 指针与引用</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 指针、引用和内存管理</h4>
                <p class="text-slate-300 mb-4">特点：指针存储内存地址，引用是变量的别名。注意事项：指针需要初始化和检查，引用必须在声明时初始化。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 指针与引用</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 指针声明和初始化</span><br>
                        <span class="text-purple-400">int</span> value = 42;<br>
                        <span class="text-purple-400">int</span>* ptr = &value; <span class="text-blue-300">// 指向value的指针</span><br>
                        std::cout &lt;&lt; <span class="text-green-300">"值: "</span> &lt;&lt; *ptr &lt;&lt; std::endl; <span class="text-blue-300">// 解引用</span><br>
                        <br>
                        <span class="text-blue-300">// 指针运算</span><br>
                        <span class="text-purple-400">int</span> arr[] = {1, 2, 3, 4, 5};<br>
                        <span class="text-purple-400">int</span>* arrPtr = arr;<br>
                        std::cout &lt;&lt; <span class="text-green-300">"第一个元素: "</span> &lt;&lt; *arrPtr &lt;&lt; std::endl;<br>
                        std::cout &lt;&lt; <span class="text-green-300">"第二个元素: "</span> &lt;&lt; *(arrPtr + 1) &lt;&lt; std::endl;<br>
                        <br>
                        <span class="text-blue-300">// 引用声明</span><br>
                        <span class="text-purple-400">int</span>& ref = value; <span class="text-blue-300">// value的引用</span><br>
                        ref = 100; <span class="text-blue-300">// 修改引用会修改原值</span><br>
                        std::cout &lt;&lt; <span class="text-green-300">"修改后的值: "</span> &lt;&lt; value &lt;&lt; std::endl;<br>
                        <br>
                        <span class="text-blue-300">// 指针和引用作为函数参数</span><br>
                        <span class="text-purple-400">auto</span> modifyByPointer = [](<span class="text-purple-400">int</span>* p) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;*p = 200;<br>
                        };<br>
                        <br>
                        <span class="text-purple-400">auto</span> modifyByReference = [](<span class="text-purple-400">int</span>& r) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;r = 300;<br>
                        };<br>
                        <br>
                        <span class="text-purple-400">int</span> num = 10;<br>
                        modifyByPointer(&num);<br>
                        std::cout &lt;&lt; <span class="textgreen-300">"指针修改后: "</span> &lt;&lt; num &lt;&lt; std::endl;<br>
                        modifyByReference(num);<br>
                        std::cout &lt;&lt; <span class="textgreen-300">"引用修改后: "</span> &lt;&lt; num &lt;&lt; std::endl;<br>
                        <br>
                        <span class="text-blue-300">// 空指针和空指针检查</span><br>
                        <span class="text-purple-400">int</span>* nullPtr = <span class="textpurple-400">nullptr</span>;<br>
                        <span class="textpurple-400">if</span> (nullPtr != <span class="textpurple-400">nullptr</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"指针非空"</span> &lt;&lt; std::endl;<br>
                        } <span class="textpurple-400">else</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"指针为空"</span> &lt;&lt; std::endl;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 7. 类与对象 -->
        <section id="section-7" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">7. 类与对象</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 类定义、对象创建和封装</h4>
                <p class="text-slate-300 mb-4">特点：类是用户定义的数据类型，包含数据成员和成员函数。注意事项：封装数据和方法，使用访问控制符(private, public, protected)。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 类与对象</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 类定义</span><br>
                        <span class="textpurple-400">class</span> Person {<br>
                        <span class="textpurple-400">private</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string name;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">int</span> age;<br>
                        <br>
                        <span class="textpurple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 构造函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Person(<span class="textpurple-400">const</span> std::string&amp; n, <span class="textpurple-400">int</span> a) : name(n), age(a) {}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 访问器方法</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string getName() <span class="textpurple-400">const</span> { <span class="textpurple-400">return</span> name; }<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">int</span> getAge() <span class="textpurple-400">const</span> { <span class="textpurple-400">return</span> age; }<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 修改器方法</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">void</span> setAge(<span class="textpurple-400">int</span> newAge) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">if</span> (newAge &gt; 0) age = newAge;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 成员函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">void</span> introduce() <span class="textpurple-400">const</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"我是 "</span> &lt;&lt; name &lt;&lt; <span class="textgreen-300">", 今年 "</span> &lt;&lt; age &lt;&lt; <span class="textgreen-300">" 岁"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        };<br>
                        <br>
                        <span class="textblue-300">// 对象创建和使用</span><br>
                        Person person1(<span class="textgreen-300">"张三"</span>, 25);<br>
                        Person person2{<span class="textgreen-300">"李四"</span>, 30}; <span class="textblue-300">// 统一初始化</span><br>
                        <br>
                        person1.introduce();<br>
                        person2.introduce();<br>
                        std::cout &lt;&lt; person1.getName() &lt;&lt; <span class="textgreen-300">" 的年龄: "</span> &lt;&lt; person1.getAge() &lt;&lt; std::endl;
                    </div>
                </div>
            </div>
        </section>

        <!-- 8. 继承与多态 -->
        <section id="section-8" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">8. 继承与多态</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 继承机制和多态性</h4>
                <p class="text-slate-300 mb-4">特点：继承允许创建新类从现有类派生，多态允许不同类的对象响应同一消息。注意事项：使用virtual关键字实现动态绑定，虚析构函数确保正确清理。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 继承与多态</div>
                    <div class="text-sm leading-6">
                        <span class="textblue-300">// 基类</span><br>
                        <span class="textpurple-400">class</span> Animal {<br>
                        <span class="textpurple-400">protected</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string name;<br>
                        <br>
                        <span class="textpurple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Animal(<span class="textpurple-400">const</span> std::string&amp; n) : name(n) {}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">virtual</span> ~Animal() = <span class="textpurple-400">default</span>; <span class="textblue-300">// 虚析构函数</span><br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">virtual</span> <span class="textpurple-400">void</span> makeSound() <span class="textpurple-400">const</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; name &lt;&lt; <span class="textgreen-300">" 发出声音"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">virtual</span> <span class="textpurple-400">void</span> move() <span class="textpurple-400">const</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; name &lt;&lt; <span class="textgreen-300">" 在移动"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        };<br>
                        <br>
                        <span class="textblue-300">// 派生类</span><br>
                        <span class="textpurple-400">class</span> Dog : <span class="textpurple-400">public</span> Animal {<br>
                        <span class="textpurple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Dog(<span class="textpurple-400">const</span> std::string&amp; n) : Animal(n) {}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">void</span> makeSound() <span class="textpurple-400">const</span> <span class="textpurple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; name &lt;&lt; <span class="textgreen-300">" 汪汪叫"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">void</span> move() <span class="textpurple-400">const</span> <span class="textpurple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; name &lt;&lt; <span class="textgreen-300">" 跑步"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        };<br>
                        <br>
                        <span class="textblue-300">// 另一个派生类</span><br>
                        <span class="textpurple-400">class</span> Cat : <span class="textpurple-400">public</span> Animal {<br>
                        <span class="textpurple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Cat(<span class="textpurple-400">const</span> std::string&amp; n) : Animal(n) {}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">void</span> makeSound() <span class="textpurple-400">const</span> <span class="textpurple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; name &lt;&lt; <span class="textgreen-300">" 喵喵叫"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">void</span> move() <span class="textpurple-400">const</span> <span class="textpurple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; name &lt;&lt; <span class="textgreen-300">" 悄悄走"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        };<br>
                        <br>
                        <span class="textblue-300">// 多态使用</span><br>
                        std::vector&lt;std::unique_ptr&lt;Animal&gt;&gt; animals;<br>
                        animals.push_back(std::make_unique&lt;Dog&gt;(<span class="textgreen-300">"旺财"</span>));<br>
                        animals.push_back(std::make_unique&lt;Cat&gt;(<span class="textgreen-300">"咪咪"</span>));<br>
                        <br>
                        <span class="textpurple-400">for</span> (<span class="textpurple-400">const</span> <span class="textpurple-400">auto</span>&amp; animal : animals) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;animal-&gt;makeSound();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;animal-&gt;move();<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 9. 模板 -->
        <section id="section-9" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">9. 模板</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 函数模板和类模板</h4>
                <p class="text-slate-300 mb-4">特点：模板允许编写泛型代码，可以处理不同数据类型。注意事项：模板在编译时实例化，可能导致代码膨胀。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 模板</div>
                    <div class="text-sm leading-6">
                        <span class="textblue-300">// 函数模板</span><br>
                        <span class="textpurple-400">template</span>&lt;<span class="textpurple-400">typename</span> T&gt;<br>
                        T max_value(<span class="textpurple-400">const</span> T&amp; a, <span class="textpurple-400">const</span> T&amp; b) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> (a &gt; b) ? a : b;<br>
                        }<br>
                        <br>
                        <span class="textblue-300">// 使用函数模板</span><br>
                        <span class="textpurple-400">int</span> int_max = max_value(5, 10);<br>
                        <span class="textpurple-400">double</span> double_max = max_value(3.14, 2.71);<br>
                        std::string str_max = max_value(std::string(<span class="textgreen-300">"apple"</span>), std::string(<span class="textgreen-300">"banana"</span>));<br>
                        <br>
                        <span class="textblue-300">// 类模板</span><br>
                        <span class="textpurple-400">template</span>&lt;<span class="textpurple-400">typename</span> T&gt;<br>
                        <span class="textpurple-400">class</span> Container {<br>
                        <span class="textpurple-400">private</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;T value;<br>
                        <br>
                        <span class="textpurple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Container(<span class="textpurple-400">const</span> T&amp; v) : value(v) {}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;T getValue() <span class="textpurple-400">const</span> { <span class="textpurple-400">return</span> value; }<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">void</span> setValue(<span class="textpurple-400">const</span> T&amp; v) { value = v; }<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 模板成员函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">template</span>&lt;<span class="textpurple-400">typename</span> U&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">void</span> printType(<span class="textpurple-400">const</span> U&amp; u) <span class="textpurple-400">const</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"类型T的值: "</span> &lt;&lt; value &lt;&lt; <span class="textgreen-300">", 类型U的值: "</span> &lt;&lt; u &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        };<br>
                        <br>
                        <span class="textblue-300">// 使用类模板</span><br>
                        Container&lt;<span class="textpurple-400">int</span>&gt; intContainer(42);<br>
                        Container&lt;std::string&gt; strContainer(<span class="textgreen-300">"Hello"</span>);<br>
                        <br>
                        std::cout &lt;&lt; <span class="textgreen-300">"整数容器: "</span> &lt;&lt; intContainer.getValue() &lt;&lt; std::endl;<br>
                        std::cout &lt;&lt; <span class="textgreen-300">"字符串容器: "</span> &lt;&lt; strContainer.getValue() &lt;&lt; std::endl;<br>
                        <br>
                        intContainer.printType(3.14);<br>
                        strContainer.printType(100);
                    </div>
                </div>
            </div>
        </section>

        <!-- 10. 异常处理 -->
        <section id="section-10" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">10. 异常处理</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 异常处理机制</h4>
                <p class="text-slate-300 mb-4">特点：使用try, catch, throw进行异常处理。注意事项：异常处理会影响性能，应仅用于异常情况，不是正常的控制流。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 异常处理</div>
                    <div class="text-sm leading-6">
                        <span class="textblue-300">// 自定义异常类</span><br>
                        <span class="textpurple-400">class</span> CustomException : <span class="textpurple-400">public</span> std::exception {<br>
                        <span class="textpurple-400">private</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string message;<br>
                        <br>
                        <span class="textpurple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;CustomException(<span class="textpurple-400">const</span> std::string&amp; msg) : message(msg) {}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">const</span> <span class="textpurple-400">char</span>* what() <span class="textpurple-400">const</span> <span class="textpurple-400">noexcept</span> <span class="textpurple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> message.c_str();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        };<br>
                        <br>
                        <span class="textblue-300">// 函数抛出异常</span><br>
                        <span class="textpurple-400">auto</span> divide = [](<span class="textpurple-400">double</span> a, <span class="textpurple-400">double</span> b) -&gt; <span class="textpurple-400">double</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">if</span> (b == 0) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">throw</span> std::invalid_argument(<span class="textgreen-300">"除数不能为零"</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> a / b;<br>
                        };<br>
                        <br>
                        <span class="textblue-300">// 异常处理示例</span><br>
                        <span class="textpurple-400">try</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"10 / 2 = "</span> &lt;&lt; divide(10, 2) &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"10 / 0 = "</span> &lt;&lt; divide(10, 0) &lt;&lt; std::endl; <span class="textblue-300">// 这会抛出异常</span><br>
                        } <span class="textpurple-400">catch</span> (<span class="textpurple-400">const</span> std::invalid_argument&amp; e) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"捕获到无效参数异常: "</span> &lt;&lt; e.what() &lt;&lt; std::endl;<br>
                        } <span class="textpurple-400">catch</span> (<span class="textpurple-400">const</span> std::exception&amp; e) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"捕获到标准异常: "</span> &lt;&lt; e.what() &lt;&lt; std::endl;<br>
                        } <span class="textpurple-400">catch</span> (...) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"捕获到未知异常"</span> &lt;&lt; std::endl;<br>
                        }<br>
                        <br>
                        <span class="textblue-300">// 自定义异常使用</span><br>
                        <span class="textpurple-400">try</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">throw</span> CustomException(<span class="textgreen-300">"这是一个自定义异常"</span>);<br>
                        } <span class="textpurple-400">catch</span> (<span class="textpurple-400">const</span> CustomException&amp; ce) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"自定义异常: "</span> &lt;&lt; ce.what() &lt;&lt; std::endl;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 11. 面向对象编程 -->
        <section id="section-11" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">11. 面向对象编程</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 面向对象编程三大特性</h4>
                <p class="text-slate-300 mb-4">特点：封装、继承、多态是面向对象编程的三大特性。注意事项：合理使用这些特性可以提高代码的可维护性和可扩展性。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 面向对象编程</div>
                    <div class="text-sm leading-6">
                        <span class="textblue-300">// 封装示例 - 银行账户类</span><br>
                        <span class="textpurple-400">class</span> BankAccount {<br>
                        <span class="textpurple-400">private</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string owner;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">double</span> balance;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">static</span> <span class="textpurple-400">int</span> totalAccounts; <span class="textblue-300">// 静态成员</span><br>
                        <br>
                        <span class="textpurple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;BankAccount(<span class="textpurple-400">const</span> std::string&amp; o, <span class="textpurple-400">double</span> initialBalance)<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: owner(o), balance(initialBalance) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totalAccounts++;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">void</span> deposit(<span class="textpurple-400">double</span> amount) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">if</span> (amount &gt; 0) balance += amount;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">bool</span> withdraw(<span class="textpurple-400">double</span> amount) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">if</span> (amount &gt; 0 &amp;&amp; amount &lt;= balance) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance -= amount;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> <span class="textpurple-400">true</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> <span class="textpurple-400">false</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">double</span> getBalance() <span class="textpurple-400">const</span> { <span class="textpurple-400">return</span> balance; }<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string getOwner() <span class="textpurple-400">const</span> { <span class="textpurple-400">return</span> owner; }<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">static</span> <span class="textpurple-400">int</span> getTotalAccounts() { <span class="textpurple-400">return</span> totalAccounts; }<br>
                        };<br>
                        <br>
                        <span class="textpurple-400">int</span> BankAccount::totalAccounts = 0; <span class="textblue-300">// 静态成员定义</span><br>
                        <br>
                        <span class="textblue-300">// 使用封装的类</span><br>
                        BankAccount account1(<span class="textgreen-300">"张三"</span>, 1000.0);<br>
                        BankAccount account2(<span class="textgreen-300">"李四"</span>, 500.0);<br>
                        <br>
                        account1.deposit(200);<br>
                        account1.withdraw(150);<br>
                        std::cout &lt;&lt; account1.getOwner() &lt;&lt; <span class="textgreen-300">" 余额: "</span> &lt;&lt; account1.getBalance() &lt;&lt; std::endl;<br>
                        std::cout &lt;&lt; <span class="textgreen-300">"总账户数: "</span> &lt;&lt; BankAccount::getTotalAccounts() &lt;&lt; std::endl;
                    </div>
                </div>
            </div>
        </section>

        <!-- 12. 继承和多态 -->
        <section id="section-12" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">12. 继承和多态</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 深入理解继承和多态机制</h4>
                <p class="text-slate-300 mb-4">特点：继承支持代码重用，多态实现运行时动态绑定。注意事项：虚函数表实现多态，纯虚函数定义接口。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 继承和多态</div>
                    <div class="text-sm leading-6">
                        <span class="textblue-300">// 抽象基类（包含纯虚函数）</span><br>
                        <span class="textpurple-400">class</span> Shape {<br>
                        <span class="textpurple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">virtual</span> ~Shape() = <span class="textpurple-400">default</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">virtual</span> <span class="textpurple-400">double</span> area() <span class="textpurple-400">const</span> = 0; <span class="textblue-300">// 纯虚函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">virtual</span> <span class="textpurple-400">double</span> perimeter() <span class="textpurple-400">const</span> = 0;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">virtual</span> <span class="textpurple-400">void</span> draw() <span class="textpurple-400">const</span> = 0;<br>
                        };<br>
                        <br>
                        <span class="textblue-300">// 派生类1 - 矩形</span><br>
                        <span class="textpurple-400">class</span> Rectangle : <span class="textpurple-400">public</span> Shape {<br>
                        <span class="textpurple-400">private</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">double</span> width, height;<br>
                        <br>
                        <span class="textpurple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Rectangle(<span class="textpurple-400">double</span> w, <span class="textpurple-400">double</span> h) : width(w), height(h) {}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">double</span> area() <span class="textpurple-400">const</span> <span class="textpurple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> width * height;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">double</span> perimeter() <span class="textpurple-400">const</span> <span class="textpurple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> 2 * (width + height);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">void</span> draw() <span class="textpurple-400">const</span> <span class="textpurple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"绘制矩形 (宽: "</span> &lt;&lt; width &lt;&lt; <span class="textgreen-300">", 高: "</span> &lt;&lt; height &lt;&lt; <span class="textgreen-300">")"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        };<br>
                        <br>
                        <span class="textblue-300">// 派生类2 - 圆形</span><br>
                        <span class="textpurple-400">class</span> Circle : <span class="textpurple-400">public</span> Shape {<br>
                        <span class="textpurple-400">private</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">double</span> radius;<br>
                        <br>
                        <span class="textpurple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Circle(<span class="textpurple-400">double</span> r) : radius(r) {}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">double</span> area() <span class="textpurple-400">const</span> <span class="textpurple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> 3.14159 * radius * radius;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">double</span> perimeter() <span class="textpurple-400">const</span> <span class="textpurple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> 2 * 3.14159 * radius;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">void</span> draw() <span class="textpurple-400">const</span> <span class="textpurple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"绘制圆形 (半径: "</span> &lt;&lt; radius &lt;&lt; <span class="textgreen-300">")"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        };<br>
                        <br>
                        <span class="textblue-300">// 多态使用示例</span><br>
                        std::vector&lt;std::unique_ptr&lt;Shape&gt;&gt; shapes;<br>
                        shapes.push_back(std::make_unique&lt;Rectangle&gt;(5.0, 3.0));<br>
                        shapes.push_back(std::make_unique&lt;Circle&gt;(2.5));<br>
                        shapes.push_back(std::make_unique&lt;Rectangle&gt;(4.0, 6.0));<br>
                        <br>
                        <span class="textpurple-400">for</span> (<span class="textpurple-400">const</span> <span class="textpurple-400">auto</span>&amp; shape : shapes) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;shape-&gt;draw();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"面积: "</span> &lt;&lt; shape-&gt;area() &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"周长: "</span> &lt;&lt; shape-&gt;perimeter() &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"---"</span> &lt;&lt; std::endl;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 13. 异常处理 -->
        <section id="section-13" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">13. 异常处理</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 高级异常处理技术</h4>
                <p class="text-slate-300 mb-4">特点：RAII、异常安全、栈展开等高级异常处理概念。注意事项：异常安全的代码需要考虑三种保证级别：基本保证、强保证、不抛异常保证。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 高级异常处理</div>
                    <div class="text-sm leading-6">
                        <span class="textblue-300">// RAII (Resource Acquisition Is Initialization) 示例</span><br>
                        <span class="textpurple-400">class</span> FileManager {<br>
                        <span class="textpurple-400">private</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::FILE* file;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string filename;<br>
                        <br>
                        <span class="textpurple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;FileManager(<span class="textpurple-400">const</span> std::string&amp; fname) : filename(fname) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file = std::fopen(fname.c_str(), <span class="textgreen-300">"w"</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">if</span> (!file) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">throw</span> std::runtime_error(<span class="textgreen-300">"无法打开文件: "</span> + fname);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;~FileManager() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">if</span> (file) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::fclose(file);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">void</span> write(<span class="textpurple-400">const</span> std::string&amp; data) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">if</span> (std::fwrite(data.c_str(), 1, data.length(), file) != data.length()) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">throw</span> std::runtime_error(<span class="textgreen-300">"写入文件失败"</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;FileManager(<span class="textpurple-400">const</span> FileManager&amp;) = <span class="textpurple-400">delete</span>; <span class="textblue-300">// 禁止拷贝</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;FileManager&amp; operator=(<span class="textpurple-400">const</span> FileManager&amp;) = <span class="textpurple-400">delete</span>;<br>
                        };<br>
                        <br>
                        <span class="textblue-300">// 异常安全的函数</span><br>
                        <span class="textpurple-400">void</span> processFile(<span class="textpurple-400">const</span> std::string&amp; filename) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;FileManager fm(filename); <span class="textblue-300">// RAII: 析构函数自动关闭文件</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;fm.write(<span class="textgreen-300">"Hello, World!"</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;fm.write(<span class="textgreen-300">"\nSecond line"</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 文件会自动关闭，即使发生异常</span><br>
                        }<br>
                        <br>
                        <span class="textblue-300">// 异常规范（C++11及以后推荐使用noexcept）</span><br>
                        <span class="textpurple-400">auto</span> safeFunction = []() <span class="textpurple-400">noexcept</span> -&gt; <span class="textpurple-400">int</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> 42; <span class="textblue-300">// 承诺不抛出异常</span><br>
                        };<br>
                        <br>
                        <span class="textblue-300">// 使用示例</span><br>
                        <span class="textpurple-400">try</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;processFile(<span class="textgreen-300">"example.txt"</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"文件处理成功"</span> &lt;&lt; std::endl;<br>
                        } <span class="textpurple-400">catch</span> (<span class="textpurple-400">const</span> std::exception&amp; e) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"错误: "</span> &lt;&lt; e.what() &lt;&lt; std::endl;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 14. 智能指针 -->
        <section id="section-14" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">14. 智能指针</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 智能指针管理动态内存</h4>
                <p class="text-slate-300 mb-4">特点：自动内存管理，防止内存泄漏。注意事项：C++11引入std::unique_ptr、std::shared_ptr、std::weak_ptr，推荐优先使用智能指针而非原始指针。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 智能指针</div>
                    <div class="text-sm leading-6">
                        <span class="textblue-300">// unique_ptr - 独占所有权</span><br>
                        {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">auto</span> ptr1 = std::make_unique&lt;std::string&gt;(<span class="textgreen-300">"Hello"</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"ptr1: "</span> &lt;&lt; *ptr1 &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">auto</span> ptr2 = std::move(ptr1); <span class="textblue-300">// 转移所有权</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">if</span> (ptr1 == <span class="textpurple-400">nullptr</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"ptr1 现在为空"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"ptr2: "</span> &lt;&lt; *ptr2 &lt;&lt; std::endl;<br>
                        } <span class="textblue-300">// ptr2在这里自动释放</span><br>
                        <br>
                        <span class="textblue-300">// shared_ptr - 共享所有权</span><br>
                        {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">auto</span> shared1 = std::make_shared&lt;int&gt;(42);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"引用计数: "</span> &lt;&lt; shared1.use_count() &lt;&lt; std::endl; <span class="textblue-300">// 输出: 1</span><br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">auto</span> shared2 = shared1; <span class="textblue-300">// 共享所有权</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"引用计数: "</span> &lt;&lt; shared1.use_count() &lt;&lt; std::endl; <span class="textblue-300">// 输出: 2</span><br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;{<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">auto</span> shared3 = shared1; <span class="textblue-300">// 又增加一个引用</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"引用计数: "</span> &lt;&lt; shared1.use_count() &lt;&lt; std::endl; <span class="textblue-300">// 输出: 3</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;} <span class="textblue-300">// shared3离开作用域，计数减1</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"引用计数: "</span> &lt;&lt; shared1.use_count() &lt;&lt; std::endl; <span class="textblue-300">// 输出: 2</span><br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"值: "</span> &lt;&lt; *shared1 &lt;&lt; std::endl;<br>
                        } <span class="textblue-300">// shared1和shared2离开作用域，内存自动释放</span><br>
                        <br>
                        <span class="textblue-300">// weak_ptr - 解决循环引用</span><br>
                        {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">auto</span> shared = std::make_shared&lt;int&gt;(100);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::weak_ptr&lt;int&gt; weak = shared; <span class="textblue-300">// 不增加引用计数</span><br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"weak_ptr 使用前引用计数: "</span> &lt;&lt; shared.use_count() &lt;&lt; std::endl; <span class="textblue-300">// 输出: 1</span><br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">if</span> (<span class="textpurple-400">auto</span> locked = weak.lock()) { <span class="textblue-300">// 获取shared_ptr的临时所有权</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"weak_ptr 指向的值: "</span> &lt;&lt; *locked &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;} <span class="textpurple-400">else</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"weak_ptr 已过期"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;shared = <span class="textpurple-400">nullptr</span>; <span class="textblue-300">// 释放shared_ptr</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">if</span> (weak.expired()) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"weak_ptr 已过期"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 15. 文件操作 -->
        <section id="section-15" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">15. 文件操作</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 文件输入输出操作</h4>
                <p class="text-slate-300 mb-4">特点：支持文本和二进制文件操作，提供多种流类型。注意事项：操作后要检查状态，及时关闭文件。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 文件操作</div>
                    <div class="text-sm leading-6">
                        <span class="textblue-300">// 写入文件</span><br>
                        {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::ofstream outFile(<span class="textgreen-300">"example.txt"</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">if</span> (outFile.is_open()) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outFile &lt;&lt; <span class="textgreen-300">"第一行文本"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outFile &lt;&lt; <span class="textgreen-300">"第二行文本"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outFile &lt;&lt; <span class="textgreen-300">"数字: "</span> &lt;&lt; 123 &lt;&lt; <span class="textgreen-300">" 浮点数: "</span> &lt;&lt; 3.14 &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outFile.close();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;} <span class="textpurple-400">else</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"无法打开文件进行写入"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        }<br>
                        <br>
                        <span class="textblue-300">// 读取文件</span><br>
                        {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::ifstream inFile(<span class="textgreen-300">"example.txt"</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">if</span> (inFile.is_open()) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string line;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">while</span> (std::getline(inFile, line)) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"读取: "</span> &lt;&lt; line &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inFile.close();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;} <span class="textpurple-400">else</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"无法打开文件进行读取"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        }<br>
                        <br>
                        <span class="textblue-300">// 二进制文件操作</span><br>
                        {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;<span class="textpurple-400">int</span>&gt; data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 写入二进制文件</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::ofstream binOut(<span class="textgreen-300">"data.bin"</span>, std::ios::binary);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">if</span> (binOut.is_open()) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binOut.write(<span class="textpurple-400">reinterpret_cast</span>&lt;<span class="textpurple-400">const</span> <span class="textpurple-400">char</span>*&gt;(data.data()),<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data.size() * <span class="textpurple-400">sizeof</span>(<span class="textpurple-400">int</span>));<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binOut.close();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 读取二进制文件</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;<span class="textpurple-400">int</span>&gt; readData(10);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::ifstream binIn(<span class="textgreen-300">"data.bin"</span>, std::ios::binary);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">if</span> (binIn.is_open()) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binIn.read(<span class="textpurple-400">reinterpret_cast</span>&lt;<span class="textpurple-400">char</span>*&gt;(readData.data()),<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;readData.size() * <span class="textpurple-400">sizeof</span>(<span class="textpurple-400">int</span>));<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binIn.close();<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"读取的二进制数据: "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">for</span> (<span class="textpurple-400">int</span> value : readData) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; value &lt;&lt; <span class="textgreen-300">" "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl;<br>
                        }<br>
                        <br>
                        <span class="textblue-300">// 随机文件访问</span><br>
                        {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::fstream file(<span class="textgreen-300">"example.txt"</span>, std::ios::in | std::ios::out);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">if</span> (file.is_open()) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 写入内容</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file &lt;&lt; <span class="textgreen-300">"Hello, World!"</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file.seekg(0); <span class="textblue-300">// 移动到文件开头</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string content;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::getline(file, content);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"文件内容: "</span> &lt;&lt; content &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file.close();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        }<br>
                        }<br>
                    </div>
                </div>
            </div>
        </section>

        <!-- 16. Lambda表达式 -->
        <section id="section-16" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">16. Lambda表达式</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - Lambda表达式</h4>
                <p class="text-slate-300 mb-4">特点：提供匿名函数功能，可以捕获外部变量，简化函数对象的创建。注意事项：捕获方式有值捕获、引用捕获、全部值捕获、全部引用捕获等。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># Lambda表达式</div>
                    <div class="text-sm leading-6">
                        <span class="textblue-300">// 基本Lambda表达式</span><br>
                        <span class="textpurple-400">auto</span> greet = []() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"Hello from Lambda!"</span> &lt;&lt; std::endl;<br>
                        };<br>
                        greet();<br>
                        <br>
                        <span class="textblue-300">// 带参数的Lambda</span><br>
                        <span class="textpurple-400">auto</span> add = [](<span class="textpurple-400">int</span> a, <span class="textpurple-400">int</span> b) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> a + b;<br>
                        };<br>
                        std::cout &lt;&lt; <span class="textgreen-300">"3 + 4 = "</span> &lt;&lt; add(3, 4) &lt;&lt; std::endl;<br>
                        <br>
                        <span class="textblue-300">// 值捕获 [=]</span><br>
                        <span class="textpurple-400">int</span> x = 10, y = 20;<br>
                        <span class="textpurple-400">auto</span> capture_by_value = [=]() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"x + y = "</span> &lt;&lt; (x + y) &lt;&lt; std::endl; <span class="textblue-300">// 捕获x和y的值</span><br>
                        };<br>
                        capture_by_value();<br>
                        <br>
                        <span class="textblue-300">// 引用捕获 [&]</span><br>
                        <span class="textpurple-400">auto</span> capture_by_ref = [&amp;]() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"x的引用值: "</span> &lt;&lt; x &lt;&lt; std::endl; <span class="textblue-300">// 捕获x和y的引用</span><br>
                        };<br>
                        capture_by_ref();<br>
                        <br>
                        <span class="textblue-300">// 混合捕获</span><br>
                        <span class="textpurple-400">auto</span> mixed_capture = [x, &amp;y]() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"x的值: "</span> &lt;&lt; x &lt;&lt; <span class="textgreen-300">", y的引用: "</span> &lt;&lt; y &lt;&lt; std::endl;<br>
                        };<br>
                        mixed_capture();<br>
                        <br>
                        <span class="textblue-300">// 修改捕获的变量(需要mutable)</span><br>
                        <span class="textpurple-400">int</span> counter = 0;<br>
                        <span class="textpurple-400">auto</span> increment = [counter]() <span class="textpurple-400">mutable</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;counter++;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"计数器: "</span> &lt;&lt; counter &lt;&lt; std::endl;<br>
                        };<br>
                        increment();<br>
                        increment();<br>
                        std::cout &lt;&lt; <span class="textgreen-300">"原始计数器值: "</span> &lt;&lt; counter &lt;&lt; std::endl; <span class="textblue-300">// 仍然是0</span><br>
                        <br>
                        <span class="textblue-300">// Lambda与STL结合使用</span><br>
                        std::vector&lt;<span class="textpurple-400">int</span>&gt; numbers = {5, 2, 8, 1, 9, 3};<br>
                        <br>
                        <span class="textblue-300">// 排序</span><br>
                        std::sort(numbers.begin(), numbers.end(), [](<span class="textpurple-400">int</span> a, <span class="textpurple-400">int</span> b) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> a &gt; b; <span class="textblue-300">// 降序排序</span><br>
                        });<br>
                        std::cout &lt;&lt; <span class="textgreen-300">"降序排序: "</span>;<br>
                        <span class="textpurple-400">for</span> (<span class="textpurple-400">int</span> n : numbers) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; n &lt;&lt; <span class="textgreen-300">" "</span>;<br>
                        }<br>
                        std::cout &lt;&lt; std::endl;<br>
                        <br>
                        <span class="textblue-300">// 查找元素</span><br>
                        <span class="textpurple-400">auto</span> find_greater_than_5 = std::find_if(numbers.begin(), numbers.end(),<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<span class="textpurple-400">int</span> n) { <span class="textpurple-400">return</span> n &gt; 5; });<br>
                        <span class="textpurple-400">if</span> (find_greater_than_5 != numbers.end()) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"找到大于5的元素: "</span> &lt;&lt; *find_greater_than_5 &lt;&lt; std::endl;<br>
                        }<br>
                        <br>
                        <span class="textblue-300">// 计算满足条件的元素数量</span><br>
                        <span class="textpurple-400">int</span> count_even = std::count_if(numbers.begin(), numbers.end(),<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<span class="textpurple-400">int</span> n) { <span class="textpurple-400">return</span> n % 2 == 0; });<br>
                        std::cout &lt;&lt; <span class="textgreen-300">"偶数数量: "</span> &lt;&lt; count_even &lt;&lt; std::endl;<br>
                        <br>
                        <span class="textblue-300">// 转换元素</span><br>
                        std::vector&lt;<span class="textpurple-400">int</span>&gt; original = {1, 2, 3, 4, 5};<br>
                        std::vector&lt;<span class="textpurple-400">int</span>&gt; doubled;<br>
                        std::transform(original.begin(), original.end(), std::back_inserter(doubled),<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<span class="textpurple-400">int</span> n) { <span class="textpurple-400">return</span> n * 2; });<br>
                        std::cout &lt;&lt; <span class="textgreen-300">"原数组翻倍: "</span>;<br>
                        <span class="textpurple-400">for</span> (<span class="textpurple-400">int</span> n : doubled) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; n &lt;&lt; <span class="textgreen-300">" "</span>;<br>
                        }<br>
                        std::cout &lt;&lt; std::endl;<br>
                        <br>
                        <span class="textblue-300">// 过滤元素</span><br>
                        std::vector&lt;<span class="textpurple-400">int</span>&gt; filtered;<br>
                        std::copy_if(numbers.begin(), numbers.end(), std::back_inserter(filtered),<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<span class="textpurple-400">int</span> n) { <span class="textpurple-400">return</span> n &gt; 3; });<br>
                        std::cout &lt;&lt; <span class="textgreen-300">"大于3的元素: "</span>;<br>
                        <span class="textpurple-400">for</span> (<span class="textpurple-400">int</span> n : filtered) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; n &lt;&lt; <span class="textgreen-300">" "</span>;<br>
                        }<br>
                        std::cout &lt;&lt; std::endl;<br>
                        <br>
                        <span class="textblue-300">// 累积计算</span><br>
                        <span class="textpurple-400">int</span> sum = std::accumulate(numbers.begin(), numbers.end(), 0);<br>
                        std::cout &lt;&lt; <span class="textgreen-300">"总和: "</span> &lt;&lt; sum &lt;&lt; std::endl;<br>
                        <br>
                        <span class="textblue-300">// 使用std::function存储Lambda</span><br>
                        std::function&lt;<span class="textpurple-400">int</span>(<span class="textpurple-400">int</span>, <span class="textpurple-400">int</span>)&gt; func = [](<span class="textpurple-400">int</span> a, <span class="textpurple-400">int</span> b) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> a * b;<br>
                        };<br>
                        std::cout &lt;&lt; <span class="textgreen-300">"使用function存储的Lambda: "</span> &lt;&lt; func(5, 6) &lt;&lt; std::endl;<br>
                        <br>
                        <span class="textblue-300">// 递归Lambda</span><br>
                        std::function&lt;<span class="textpurple-400">int</span>(<span class="textpurple-400">int</span>)&gt; factorial = [&amp;](<span class="textpurple-400">int</span> n) -&gt; <span class="textpurple-400">int</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">if</span> (n &lt;= 1) <span class="textpurple-400">return</span> 1;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> n * factorial(n - 1);<br>
                        };<br>
                        std::cout &lt;&lt; <span class="textgreen-300">"5的阶乘: "</span> &lt;&lt; factorial(5) &lt;&lt; std::endl;
                    </div>
                </div>
            </div>
        </section>

        <!-- 17. 移动语义 -->
        <section id="section-17" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">17. 移动语义</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 移动语义 (Move Semantics)</h4>
                <p class="text-slate-300 mb-4">特点：C++11引入的移动语义，允许将资源从一个对象转移到另一个对象，避免不必要的拷贝操作，提高性能。注意事项：使用std::move进行移动操作，理解左值和右值的区别，实现移动构造函数和移动赋值运算符。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 移动语义示例</div>
                    <div class="text-sm leading-6">
                        <span class="textblue-300">#include &lt;iostream&gt;</span><br>
                        <span class="textblue-300">#include &lt;vector&gt;</span><br>
                        <span class="textblue-300">#include &lt;string&gt;</span><br>
                        <span class="textblue-300">#include &lt;utility&gt;</span><br>
                        <br>
                        <span class="textpurple-400">class</span> <span class="textyellow-300">MyClass</span> {<br>
                        <span class="textpurple-400">private</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;<span class="textpurple-400">int</span>&gt; data;<br>
                        <br>
                        <span class="textpurple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 普通构造函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textyellow-300">MyClass</span>(<span class="textpurple-400">int</span> size) : data(size) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"构造函数: "</span> &lt;&lt; size &lt;&lt; <span class="textgreen-300">" 个元素"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 拷贝构造函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textyellow-300">MyClass</span>(<span class="textpurple-400">const</span> MyClass&amp; other) : data(other.data) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"拷贝构造函数"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 移动构造函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textyellow-300">MyClass</span>(MyClass&amp;&amp; other) <span class="textpurple-400">noexcept</span> : data(std::move(other.data)) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"移动构造函数"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 拷贝赋值运算符</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;MyClass&amp; <span class="textyellow-300">operator=</span>(<span class="textpurple-400">const</span> MyClass&amp; other) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"拷贝赋值运算符"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">if</span> (<span class="textpurple-400">this</span> != &amp;other) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data = other.data;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> *<span class="textpurple-400">this</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 移动赋值运算符</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;MyClass&amp; <span class="textyellow-300">operator=</span>(MyClass&amp;&amp; other) <span class="textpurple-400">noexcept</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"移动赋值运算符"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">if</span> (<span class="textpurple-400">this</span> != &amp;other) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data = std::move(other.data);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> *<span class="textpurple-400">this</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 打印数据</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">void</span> <span class="textyellow-300">printData</span>() <span class="textpurple-400">const</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"数据: "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">for</span> (<span class="textpurple-400">const</span> <span class="textpurple-400">auto</span>&amp; item : data) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; item &lt;&lt; <span class="textgreen-300">" "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 获取数据大小</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">size_t</span> <span class="textyellow-300">size</span>() <span class="textpurple-400">const</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> data.size();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        };<br>
                        <br>
                        <span class="textpurple-400">void</span> <span class="textyellow-300">move_semantics_examples</span>() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"=== 移动语义示例 ==="</span> &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 1. 移动构造函数的使用</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"\n1. 移动构造函数:"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;MyClass&gt; container;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 使用push_back添加元素 - 会触发拷贝或移动</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;container.push_back(MyClass(5)); <span class="textblue-300">// 临时对象，可以被移动</span><br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 使用emplace_back - 直接在容器中构造对象</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;container.emplace_back(10);<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 2. std::move的使用</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"\n2. std::move的使用:"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;MyClass obj1(7);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;MyClass obj2 = std::move(obj1); <span class="textblue-300">// 显式移动obj1到obj2</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"移动后obj1的大小: "</span> &lt;&lt; obj1.size() &lt;&lt; std::endl; <span class="textblue-300">// 通常为空</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"移动后obj2的大小: "</span> &lt;&lt; obj2.size() &lt;&lt; std::endl; <span class="textblue-300">// 应该是7</span><br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 3. 移动赋值运算符</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"\n3. 移动赋值运算符:"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;MyClass obj3(3);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;MyClass obj4(8);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;obj4 = std::move(obj3); <span class="textblue-300">// 将obj3移动到obj4</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"移动后obj3的大小: "</span> &lt;&lt; obj3.size() &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"移动后obj4的大小: "</span> &lt;&lt; obj4.size() &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 4. 右值引用</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"\n4. 右值引用:"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">auto</span>&amp;&amp; rvalue_ref = MyClass(15); <span class="textblue-300">// 绑定到临时对象</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"右值引用对象大小: "</span> &lt;&lt; rvalue_ref.size() &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 5. 移动语义在函数中的应用</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"\n5. 函数中的移动语义:"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">auto</span> process_large_data = []() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;<span class="textpurple-400">int</span>&gt; large_data(1000000, 42); <span class="textblue-300">// 大型数据</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> large_data; <span class="textblue-300">// 返回时会使用移动构造函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;};<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;<span class="textpurple-400">int</span>&gt; result = process_large_data(); <span class="textblue-300">// 移动而非拷贝</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"处理后的数据大小: "</span> &lt;&lt; result.size() &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 6. 容器的移动操作</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"\n6. 容器的移动操作:"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;std::string&gt; vec1 = {<span class="textgreen-300">"hello"</span>, <span class="textgreen-300">"world"</span>, <span class="textgreen-300">"C++"</span>, <span class="textgreen-300">"move"</span>};<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;std::string&gt; vec2 = std::move(vec1); <span class="textblue-300">// 移动整个vector</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"移动后vec1大小: "</span> &lt;&lt; vec1.size() &lt;&lt; std::endl; <span class="textblue-300">// 0</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"移动后vec2大小: "</span> &lt;&lt; vec2.size() &lt;&lt; std::endl; <span class="textblue-300">// 4</span><br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 7. 性能比较示例</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"\n7. 性能比较示例:"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;MyClass&gt; vec_copy;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;MyClass temp_obj(100);<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 拷贝操作</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;vec_copy.push_back(temp_obj); <span class="textblue-300">// 触发拷贝构造</span><br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 移动操作</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;vec_copy.push_back(std::move(temp_obj)); <span class="textblue-300">// 触发移动构造</span><br>
                        }<br>
                        <br>
                        <span class="textpurple-400">int</span> main() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;move_semantics_examples();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> 0;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 18. 基于范围的for循环 -->
        <section id="section-18" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">18. 基于范围的for循环</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 基于范围的for循环 (Range-based for loop)</h4>
                <p class="text-slate-300 mb-4">特点：C++11引入了基于范围的for循环，使遍历容器和数组更加简洁易读。语法：for (declaration : expression)，其中expression是一个序列，declaration是元素的声明。注意事项：可以使用auto关键字和引用，避免不必要的拷贝。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 基于范围的for循环</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 遍历数组</span><br>
                        <span class="text-purple-400">int</span> arr[] = {1, 2, 3, 4, 5};<br>
                        <span class="text-purple-400">for</span> (<span class="text-purple-400">int</span> element : arr) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; element &lt;&lt; <span class="text-green-300">" "</span>;<br>
                        }<br>
                        std::cout &lt;&lt; std::endl;<br>
                        <br>
                        <span class="text-blue-300">// 遍历vector</span><br>
                        <span class="text-purple-400">std::vector</span>&lt;<span class="text-purple-400">int</span>&gt; vec = {10, 20, 30, 40, 50};<br>
                        <span class="text-purple-400">for</span> (<span class="text-purple-400">const</span> <span class="text-purple-400">auto</span>& item : vec) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; item &lt;&lt; <span class="text-green-300">" "</span>;<br>
                        }<br>
                        std::cout &lt;&lt; std::endl;<br>
                        <br>
                        <span class="text-blue-300">// 修改容器中的元素</span><br>
                        <span class="text-purple-400">for</span> (<span class="text-purple-400">auto</span>& item : vec) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;item *= 2; <span class="text-blue-300">// 修改原始元素</span><br>
                        }<br>
                        <br>
                        <span class="text-blue-300">// 遍历字符串</span><br>
                        <span class="text-purple-400">std::string</span> str = <span class="text-green-300">"Hello"</span>;<br>
                        <span class="text-purple-400">for</span> (<span class="text-purple-400">char</span> c : str) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; c &lt;&lt; <span class="text-green-300">" "</span>;<br>
                        }<br>
                        std::cout &lt;&lt; std::endl;<br>
                        <br>
                        <span class="text-blue-300">// 遍历关联容器</span><br>
                        <span class="text-purple-400">std::map</span>&lt;<span class="text-purple-400">std::string</span>, <span class="text-purple-400">int</span>&gt; myMap = {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;{<span class="text-green-300">"apple"</span>, 1}, {<span class="text-green-300">"banana"</span>, 2}, {<span class="text-green-300">"orange"</span>, 3}<br>
                        };<br>
                        <span class="text-purple-400">for</span> (<span class="text-purple-400">const</span> <span class="text-purple-400">auto</span>& pair : myMap) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; pair.first &lt;&lt; <span class="text-green-300">": "</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 19. nullptr关键字 -->
        <section id="section-19" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">19. nullptr关键字</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - nullptr关键字</h4>
                <p class="text-slate-300 mb-4">特点：C++11引入了nullptr关键字，作为空指针的专用字面量，解决了传统NULL宏存在的类型安全问题。注意事项：使用nullptr代替NULL或0来表示空指针，避免函数重载时的二义性问题。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># nullptr的使用</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 传统C风格的空指针表示（不推荐）</span><br>
                        <span class="text-purple-400">int</span>* ptr1 = <span class="text-yellow-300">0</span>;<br>
                        <span class="text-purple-400">int</span>* ptr2 = NULL;<br>
                        <br>
                        <span class="text-blue-300">// C++11推荐的空指针表示</span><br>
                        <span class="text-purple-400">int</span>* ptr3 = <span class="text-purple-400">nullptr</span>;<br>
                        <br>
                        <span class="text-blue-300">// nullptr的类型安全性</span><br>
                        <span class="text-purple-400">void</span> <span class="text-yellow-300">func</span>(<span class="text-purple-400">int</span> i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"调用func(int): "</span> &lt;&lt; i &lt;&lt; std::endl;<br>
                        }<br>
                        <br>
                        <span class="text-purple-400">void</span> <span class="text-yellow-300">func</span>(<span class="text-purple-400">int</span>* ptr) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"调用func(int*): "</span> &lt;&lt; <span class="text-purple-400">static_cast</span>&lt;<span class="text-purple-400">void</span>*&gt;(ptr) &lt;&lt; std::endl;<br>
                        }<br>
                        <br>
                        <span class="text-purple-400">func</span>(<span class="text-yellow-300">0</span>); <span class="text-blue-300">// 调用func(int)</span><br>
                        <span class="text-purple-400">func</span>(NULL); <span class="text-blue-300">// 可能调用func(int)或func(int*)，存在二义性</span><br>
                        <span class="text-purple-400">func</span>(<span class="text-purple-400">nullptr</span>); <span class="text-blue-300">// 明确调用func(int*)</span><br>
                        <br>
                        <span class="text-blue-300">// 检查指针是否为空</span><br>
                        <span class="text-purple-400">if</span> (ptr3 == <span class="text-purple-400">nullptr</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"ptr3是空指针"</span> &lt;&lt; std::endl;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 20. 强类型枚举 -->
        <section id="section-20" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">20. 强类型枚举</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 强类型枚举 (Strongly-typed enums)</h4>
                <p class="text-slate-300 mb-4">特点：C++11引入了enum class（强类型枚举），解决了传统枚举的类型安全问题和命名空间污染问题。注意事项：强类型枚举不能隐式转换为整型，必须显式转换；枚举值作用域限制在枚举类内部，避免命名冲突。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 强类型枚举的使用</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 传统枚举（存在类型安全和命名空间问题）</span><br>
                        <span class="text-purple-400">enum</span> Color { RED, GREEN, BLUE };<br>
                        <span class="text-purple-400">enum</span> Status { FAILED, SUCCESS }; <span class="text-blue-300">// 与Color中的值冲突</span><br>
                        <br>
                        <span class="text-blue-300">// 强类型枚举（类型安全）</span><br>
                        <span class="text-purple-400">enum class</span> ColorClass { RED, GREEN, BLUE };<br>
                        <span class="text-purple-400">enum class</span> StatusClass { FAILED, SUCCESS }; <span class="text-blue-300">// 不会冲突</span><br>
                        <br>
                        <span class="text-blue-300">// 使用强类型枚举</span><br>
                        ColorClass color = ColorClass::RED;<br>
                        StatusClass status = StatusClass::SUCCESS;<br>
                        <br>
                        <span class="text-blue-300">// 强类型枚举不能隐式转换为整型</span><br>
                        <span class="text-purple-400">int</span> num = <span class="text-purple-400">static_cast</span>&lt;<span class="text-purple-400">int</span>&gt;(ColorClass::RED); <span class="text-blue-300">// 显式转换</span><br>
                        <br>
                        <span class="text-blue-300">// 指定底层类型</span><br>
                        <span class="text-purple-400">enum class</span> Priority : <span class="text-purple-400">unsigned</span> <span class="text-purple-400">char</span> { LOW, MEDIUM, HIGH };<br>
                        Priority priority = Priority::HIGH;<br>
                        <br>
                        <span class="text-blue-300">// 强类型枚举的优势示例</span><br>
                        <span class="text-purple-400">void</span> <span class="text-yellow-300">SetColor</span>(ColorClass c) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">if</span> (c == ColorClass::RED) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"设置颜色为红色"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        }<br>
                        <br>
                        <span class="textblue-300">// SetColor(RED); // 编译错误，类型不匹配</span><br>
                        SetColor(ColorClass::RED); <span class="text-blue-300">// 正确的调用方式</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- 21. 可变参数模板 -->
        <section id="section-21" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">21. 可变参数模板</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 可变参数模板 (Variadic templates)</h4>
                <p class="text-slate-300 mb-4">特点：C++11引入了可变参数模板，允许模板接受任意数量和类型的参数，提供了更灵活的泛型编程能力。注意事项：使用参数包（parameter pack）和展开操作（pack expansion）来处理参数；递归展开或使用折叠表达式（C++17）来处理参数包。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 可变参数模板的使用</div>
                    <div class="text-sm leading-6">
                        <span class="text-blue-300">// 可变参数模板函数</span><br>
                        <span class="text-purple-400">template</span>&lt;<span class="text-purple-400">typename</span>... Args&gt;<br>
                        <span class="text-purple-400">void</span> <span class="text-yellow-300">Print</span>(Args... args) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="text-green-300">"参数数量: "</span> &lt;&lt; <span class="text-purple-400">sizeof</span>...(args) &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;(<span class="textpurple-400">void</span>)std::initializer_list&lt;<span class="textpurple-400">int</span>&gt;{ ((std::cout &lt;&lt; args &lt;&lt; <span class="textgreen-300">" "</span>), 0)... };<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl;<br>
                        }<br>
                        <br>
                        <span class="text-blue-300">// 递归方式展开参数包</span><br>
                        <span class="text-purple-400">template</span>&lt;<span class="text-purple-400">typename</span> T&gt;<br>
                        <span class="text-purple-400">void</span> <span class="text-yellow-300">PrintRecursive</span>(T&amp;&amp; t) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; t &lt;&lt; std::endl;<br>
                        }<br>
                        <br>
                        <span class="text-purple-400">template</span>&lt;<span class="text-purple-400">typename</span> T, <span class="text-purple-400">typename</span>... Args&gt;<br>
                        <span class="text-purple-400">void</span> <span class="text-yellow-300">PrintRecursive</span>(T&amp;&amp; t, Args&amp;&amp;... args) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; t &lt;&lt; <span class="text-green-300">" "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;PrintRecursive(args...);<br>
                        }<br>
                        <br>
                        <span class="text-blue-300">// 可变参数模板类</span><br>
                        <span class="text-purple-400">template</span>&lt;<span class="text-purple-400">typename</span>... Types&gt;<br>
                        <span class="text-purple-400">struct</span> <span class="text-blue-300">Tuple</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-300">Tuple</span>(Types... args) : values(args...) {}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::tuple&lt;Types...&gt; values;<br>
                        };<br>
                        <br>
                        <span class="text-blue-300">// 使用示例</span><br>
                        Print(1, 2.5, <span class="text-green-300">"hello"</span>, <span class="textgreen-300">'c'</span>);<br>
                        PrintRecursive(10, <span class="textgreen-300">"world"</span>, 3.14);<br>
                        <br>
                        Tuple&lt;<span class="textpurple-400">int</span>, <span class="textpurple-400">double</span>, std::string&gt; t(42, 3.14, <span class="textgreen-300">"example"</span>);
                    </div>
                </div>
            </div>
        </section>

        <!-- 22. 线程库 -->
        <section id="section-22" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">22. 线程库</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 线程库 (Threading library)</h4>
                <p class="text-slate-300 mb-4">特点：C++11引入了标准线程库，提供了跨平台的多线程编程支持，包括std::thread、std::mutex、std::condition_variable等组件。注意事项：需要链接线程库（如-lpthread），注意避免竞态条件和死锁问题。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 线程库的使用</div>
                    <div class="text-sm leading-6">
                        <span class="textblue-300">#include &lt;thread&gt;</span><br>
                        <span class="textblue-300">#include &lt;mutex&gt;</span><br>
                        <span class="textblue-300">#include &lt;condition_variable&gt;</span><br>
                        <span class="textblue-300">#include &lt;iostream&gt;</span><br>
                        <br>
                        <span class="textpurple-400">int</span> shared_data = 0;<br>
                        std::mutex mtx;<br>
                        <br>
                        <span class="textpurple-400">void</span> <span class="textyellow-300">worker</span>(<span class="textpurple-400">int</span> id) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::lock_guard&lt;std::mutex&gt; lock(mtx);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"线程 "</span> &lt;&lt; id &lt;&lt; <span class="textgreen-300">" 修改数据: "</span> &lt;&lt; ++shared_data &lt;&lt; std::endl;<br>
                        }<br>
                        <br>
                        <span class="textpurple-400">void</span> <span class="textyellow-300">producer</span>(std::condition_variable&amp; cv, <span class="textpurple-400">bool</span>& ready) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::this_thread::sleep_for(std::chrono::seconds(1));<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;{<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::lock_guard&lt;std::mutex&gt; lock(mtx);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ready = <span class="textpurple-400">true</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"生产者: 数据已准备"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;cv.notify_one();<br>
                        }<br>
                        <br>
                        <span class="textpurple-400">void</span> <span class="textyellow-300">consumer</span>(std::condition_variable&amp; cv, <span class="textpurple-400">bool</span>& ready) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;{<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::unique_lock&lt;std::mutex&gt; lock(mtx);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cv.wait(lock, [&amp;]{ <span class="textpurple-400">return</span> ready; });<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"消费者: 数据已接收"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        }<br>
                        <br>
                        <span class="textblue-300">// 使用示例</span><br>
                        <span class="textpurple-400">int</span> main() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"主线程 ID: "</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 创建线程</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::thread t1(worker, 1);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::thread t2(worker, 2);<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 等待线程完成</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;t1.join();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;t2.join();<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"共享数据最终值: "</span> &lt;&lt; shared_data &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 条件变量示例</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">bool</span> ready = <span class="textpurple-400">false</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::condition_variable cv;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::thread producer_thread(producer, std::ref(cv), std::ref(ready));<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::thread consumer_thread(consumer, std::ref(cv), std::ref(ready));<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;producer_thread.join();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;consumer_thread.join();<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> 0;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 23. 正则表达式库 -->
        <section id="section-23" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">23. 正则表达式库</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 正则表达式库 (Regular expression library)</h4>
                <p class="text-slate-300 mb-4">特点：C++11引入了正则表达式库，提供了std::regex、std::regex_match、std::regex_search等组件，用于模式匹配和文本处理。注意事项：正则表达式语法可能因实现而异，注意性能开销，复杂表达式可能影响程序效率。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 正则表达式库的使用</div>
                    <div class="text-sm leading-6">
                        <span class="textblue-300">#include &lt;regex&gt;</span><br>
                        <span class="textblue-300">#include &lt;iostream&gt;</span><br>
                        <span class="textblue-300">#include &lt;string&gt;</span><br>
                        <br>
                        <span class="textpurple-400">void</span> <span class="textyellow-300">regex_examples</span>() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string text = <span class="textgreen-300">"Email: example@domain.com and phone: 123-456-7890"</span>;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 邮箱匹配</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::regex email_pattern(<span class="textgreen-300">R"(\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b)"</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::smatch email_match;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">if</span> (std::regex_search(text, email_match, email_pattern)) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"找到邮箱: "</span> &lt;&lt; email_match[0] &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 电话号码匹配</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::regex phone_pattern(<span class="textgreen-300">R"(\b\d{3}-\d{3}-\d{4}\b)"</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::smatch phone_match;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string::const_iterator search_start(text.cbegin());<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">while</span> (std::regex_search(search_start, text.cend(), phone_match, phone_pattern)) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"找到电话: "</span> &lt;&lt; phone_match[0] &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;search_start = phone_match.suffix().first;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 完全匹配</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string date = <span class="textgreen-300">"2023-12-25"</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::regex date_pattern(<span class="textgreen-300">R"(^\d{4}-\d{2}-\d{2}$)"</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">if</span> (std::regex_match(date, date_pattern)) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"日期格式正确"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 替换操作</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string original = <span class="textgreen-300">"Hello, World! Welcome to World!"</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::regex world_pattern(<span class="textgreen-300">"World"</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string replaced = std::regex_replace(original, world_pattern, <span class="textgreen-300">"C++"</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"替换后: "</span> &lt;&lt; replaced &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 捕获组示例</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string url = <span class="textgreen-300">"https://www.example.com/path/to/page"</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::regex url_pattern(<span class="textgreen-300">R"(https?)://([^/]+)/(.*)"</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::smatch url_match;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">if</span> (std::regex_match(url, url_match, url_pattern)) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"协议: "</span> &lt;&lt; url_match[1] &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"域名: "</span> &lt;&lt; url_match[2] &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"路径: "</span> &lt;&lt; url_match[3] &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        }<br>
                        <br>
                        <span class="textpurple-400">int</span> main() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;regex_examples();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> 0;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 24. std::function和std::bind -->
        <section id="section-24" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">24. std::function和std::bind</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - std::function和std::bind (std::function and std::bind)</h4>
                <p class="text-slate-300 mb-4">特点：std::function是一个通用的函数包装器，可以存储、复制和调用任何可调用对象；std::bind用于绑定函数参数，创建新的可调用对象。注意事项：std::function使用类型擦除技术，有一定性能开销；std::bind可与lambda表达式配合使用，但C++11后lambda通常更简洁。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># std::function和std::bind的使用</div>
                    <div class="text-sm leading-6">
                        <span class="textblue-300">#include &lt;functional&gt;</span><br>
                        <span class="textblue-300">#include &lt;iostream&gt;</span><br>
                        <span class="textblue-300">#include &lt;vector&gt;</span><br>
                        <br>
                        <span class="textpurple-400">int</span> <span class="textyellow-300">add</span>(<span class="textpurple-400">int</span> a, <span class="textpurple-400">int</span> b) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> a + b;<br>
                        }<br>
                        <br>
                        <span class="textpurple-400">class</span> <span class="textblue-300">Calculator</span> {<br>
                        <span class="textpurple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">int</span> <span class="textyellow-300">multiply</span>(<span class="textpurple-400">int</span> x, <span class="textpurple-400">int</span> y) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> x * y;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">int</span> <span class="textyellow-300">calculate</span>(<span class="textpurple-400">int</span> a, <span class="textpurple-400">int</span> b, <span class="textpurple-400">int</span> c) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> (a + b) * c;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        };<br>
                        <br>
                        <span class="textpurple-400">void</span> <span class="textyellow-300">function_bind_examples</span>() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// std::function示例</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::function&lt;<span class="textpurple-400">int</span>(<span class="textpurple-400">int</span>, <span class="textpurple-400">int</span>)&gt; func;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 绑定普通函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;func = add;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"add(5, 3) = "</span> &lt;&lt; func(5, 3) &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 绑定lambda表达式</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;func = [](<span class="textpurple-400">int</span> a, <span class="textpurple-400">int</span> b) { <span class="textpurple-400">return</span> a * b; };<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"lambda(5, 3) = "</span> &lt;&lt; func(5, 3) &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 绑定成员函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Calculator calc;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;func = std::bind(&amp;Calculator::multiply, &amp;calc, std::placeholders::_1, std::placeholders::_2);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"multiply(5, 3) = "</span> &lt;&lt; func(5, 3) &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 使用bind创建部分应用函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;auto multiply_by_10 = std::bind(&amp;Calculator::multiply, &amp;calc, 10, std::placeholders::_1);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"multiply_by_10(5) = "</span> &lt;&lt; multiply_by_10(5) &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 绑定带默认参数的函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;auto calc_partial = std::bind(&amp;Calculator::calculate, &amp;calc, std::placeholders::_1, 5, std::placeholders::_2);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"calc_partial(3, 2) = "</span> &lt;&lt; calc_partial(3, 2) &lt;&lt; std::endl; <span class="textblue-300">// (3+5)*2 = 16</span><br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 在容器中存储不同类型的可调用对象</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;std::function&lt;<span class="textpurple-400">int</span>(<span class="textpurple-400">int</span>, <span class="textpurple-400">int</span>)&gt;&gt; operations;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;operations.push_back(add);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;operations.push_back([](<span class="textpurple-400">int</span> a, <span class="textpurple-400">int</span> b) { <span class="textpurple-400">return</span> a - b; });<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;operations.push_back(std::bind(&amp;Calculator::multiply, &amp;calc, std::placeholders::_1, std::placeholders::_2));<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"\n操作列表:"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">for</span> (<span class="textpurple-400">size_t</span> i = 0; i &lt; operations.size(); ++i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"操作 "</span> &lt;&lt; i + 1 &lt;&lt; <span class="textgreen-300">": "</span> &lt;&lt; operations[i](10, 5) &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        }<br>
                        <br>
                        <span class="textpurple-400">int</span> main() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;function_bind_examples();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> 0;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 25. 新的字符串字面量 -->
        <section id="section-25" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">25. 新的字符串字面量</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 新的字符串字面量 (New string literals)</h4>
                <p class="text-slate-300 mb-4">特点：C++11引入了原始字符串字面量（R-strings）和用户定义字面量，使字符串处理更加灵活。注意事项：原始字符串字面量使用R"(...)"语法，避免转义字符；用户定义字面量需要定义后缀操作符函数。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 新的字符串字面量的使用</div>
                    <div class="text-sm leading-6">
                        <span class="textblue-300">#include &lt;iostream&gt;</span><br>
                        <span class="textblue-300">#include &lt;string&gt;</span><br>
                        <span class="textblue-300">#include &lt;chrono&gt;</span><br>
                        <br>
                        <span class="textpurple-400">void</span> <span class="textyellow-300">string_literal_examples</span>() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 原始字符串字面量</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string raw_string = R<span class="textgreen-300">"(
                        &nbsp;&nbsp;&nbsp;&nbsp;这是多行字符串，
                        &nbsp;&nbsp;&nbsp;&nbsp;包含"引号"和\转义字符\，
                        &nbsp;&nbsp;&nbsp;&nbsp;无需转义！
                        )"</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"原始字符串:\n"</span> &lt;&lt; raw_string &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 原始字符串中的正则表达式</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string regex_pattern = R<span class="textgreen-300">"(\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b)"</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"\n正则表达式: "</span> &lt;&lt; regex_pattern &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 原始字符串用于SQL查询</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string sql_query = R<span class="textgreen-300">"(SELECT * FROM users WHERE name = "John" AND age &gt; 18)"</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"\nSQL查询: "</span> &lt;&lt; sql_query &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 不同分隔符的原始字符串</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string custom_delim = R<span class="textgreen-300">"delimiter(This string contains " and ) characters without escaping)delimiter"</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"\n自定义分隔符: "</span> &lt;&lt; custom_delim &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 用户定义字面量示例</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">long</span> <span class="textpurple-400">long</span> <span class="textpurple-400">operator</span><span class="textpurple-400">""</span>_km(<span class="textpurple-400">unsigned</span> <span class="textpurple-400">long</span> <span class="textpurple-400">long</span> value) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> value * 1000; <span class="textblue-300">// 转换为米</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">long</span> <span class="textpurple-400">long</span> <span class="textpurple-400">operator</span><span class="textpurple-400">""</span>_m(<span class="textpurple-400">unsigned</span> <span class="textpurple-400">long</span> <span class="textpurple-400">long</span> value) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> value; <span class="textblue-300">// 保持米单位</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">double</span> <span class="textpurple-400">operator</span><span class="textpurple-400">""</span>_cm(<span class="textpurple-400">long</span> <span class="textpurple-400">double</span> value) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> value / 100.0; <span class="textblue-300">// 转换为米</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 使用用户定义字面量</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">auto</span> distance1 = 5_km; <span class="textblue-300">// 5000米</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">auto</span> distance2 = 10_m; <span class="textblue-300">// 10米</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">auto</span> distance3 = 150.0_cm; <span class="textblue-300">// 1.5米</span><br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"\n距离计算:"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"5_km = "</span> &lt;&lt; distance1 &lt;&lt; <span class="textgreen-300">" 米"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"10_m = "</span> &lt;&lt; distance2 &lt;&lt; <span class="textgreen-300">" 米"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"150.0_cm = "</span> &lt;&lt; distance3 &lt;&lt; <span class="textgreen-300">" 米"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"总距离: "</span> &lt;&lt; (distance1 + distance2 + distance3) &lt;&lt; <span class="textgreen-300">" 米"</span> &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 时间字面量示例</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">using</span> <span class="textpurple-400">namespace</span> std::chrono_literals;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">auto</span> duration = 24h + 30min + 45s; <span class="textblue-300">// C++14风格，需要#include &lt;chrono&gt;</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"\n时间计算示例（需要C++14）"</span> &lt;&lt; std::endl;<br>
                        }<br>
                        <br>
                        <span class="textpurple-400">int</span> main() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;string_literal_examples();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> 0;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 26. 委托构造函数和继承构造函数 -->
        <section id="section-26" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">26. 委托构造函数和继承构造函数</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 委托构造函数和继承构造函数 (Delegating and Inheriting constructors)</h4>
                <p class="text-slate-300 mb-4">特点：委托构造函数允许一个构造函数调用同一个类的另一个构造函数，避免代码重复；继承构造函数允许派生类继承基类的构造函数。注意事项：委托构造函数使用冒号语法调用同一类的其他构造函数；继承构造函数使用using声明引入基类构造函数。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 委托构造函数和继承构造函数的使用</div>
                    <div class="text-sm leading-6">
                        <span class="textblue-300">#include &lt;iostream&gt;</span><br>
                        <span class="textblue-300">#include &lt;string&gt;</span><br>
                        <br>
                        <span class="textpurple-400">class</span> <span class="textblue-300">Rectangle</span> {<br>
                        <span class="textpurple-400">private</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">double</span> width, height;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string color;<br>
                        <br>
                        <span class="textpurple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 基础构造函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Rectangle(<span class="textpurple-400">double</span> w, <span class="textpurple-400">double</span> h, <span class="textpurple-400">const</span> std::string&amp; c) : width(w), height(h), color(c) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"创建矩形: "</span> &lt;&lt; width &lt;&lt; <span class="textgreen-300">"x"</span> &lt;&lt; height &lt;&lt; <span class="textgreen-300">" 颜色: "</span> &lt;&lt; color &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 委托构造函数 - 使用默认颜色</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Rectangle(<span class="textpurple-400">double</span> w, <span class="textpurple-400">double</span> h) : Rectangle(w, h, <span class="textgreen-300">"白色"</span>) {}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 委托构造函数 - 创建正方形</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Rectangle(<span class="textpurple-400">double</span> side) : Rectangle(side, side, <span class="textgreen-300">"白色"</span>) {}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 默认构造函数 - 委托给其他构造函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Rectangle() : Rectangle(1.0, 1.0, <span class="textgreen-300">"白色"</span>) {}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 获取信息的方法</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">double</span> getArea() <span class="textpurple-400">const</span> { <span class="textpurple-400">return</span> width * height; }<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">double</span> getPerimeter() <span class="textpurple-400">const</span> { <span class="textpurple-400">return</span> 2 * (width + height); }<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">void</span> printInfo() <span class="textpurple-400">const</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"矩形: "</span> &lt;&lt; width &lt;&lt; <span class="textgreen-300">"x"</span> &lt;&lt; height &lt;&lt; <span class="textgreen-300">" 颜色: "</span> &lt;&lt; color<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; <span class="textgreen-300">" 面积: "</span> &lt;&lt; getArea() &lt;&lt; <span class="textgreen-300">" 周长: "</span> &lt;&lt; getPerimeter() &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        };<br>
                        <br>
                        <span class="textpurple-400">class</span> <span class="textblue-300">Shape</span> {<br>
                        <span class="textpurple-400">protected</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string name;<br>
                        <span class="textpurple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Shape(<span class="textpurple-400">const</span> std::string&amp; n) : name(n) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"创建形状: "</span> &lt;&lt; name &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Shape(<span class="textpurple-400">const</span> std::string&amp; n, <span class="textpurple-400">int</span> id) : name(n + <span class="textgreen-300">"-"</span> + std::to_string(id)) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"创建形状: "</span> &lt;&lt; name &lt;&lt; <span class="textgreen-300">" (ID: "</span> + std::to_string(id) + <span class="textgreen-300">")"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::string getName() <span class="textpurple-400">const</span> { <span class="textpurple-400">return</span> name; }<br>
                        };<br>
                        <br>
                        <span class="textpurple-400">class</span> <span class="textblue-300">Circle</span> : <span class="textpurple-400">public</span> Shape {<br>
                        <span class="textpurple-400">private</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">double</span> radius;<br>
                        <br>
                        <span class="textpurple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 继承基类的构造函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">using</span> Shape::Shape;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 特定的Circle构造函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Circle(<span class="textpurple-400">double</span> r) : Shape(<span class="textgreen-300">"圆形"</span>), radius(r) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"半径: "</span> &lt;&lt; radius &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Circle(<span class="textpurple-400">const</span> std::string&amp; n, <span class="textpurple-400">double</span> r) : Shape(n), radius(r) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"半径: "</span> &lt;&lt; radius &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">double</span> getArea() <span class="textpurple-400">const</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> 3.14159 * radius * radius;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        };<br>
                        <br>
                        <span class="textpurple-400">void</span> <span class="textyellow-300">constructor_examples</span>() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"=== 委托构造函数示例 ==="</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Rectangle rect1; <span class="textblue-300">// 调用默认构造函数，委托给三参数构造函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Rectangle rect2(5.0); <span class="textblue-300">// 调用单参数构造函数，委托创建正方形</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Rectangle rect3(3.0, 4.0); <span class="textblue-300">// 调用两参数构造函数，委托给三参数构造函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Rectangle rect4(2.0, 3.0, <span class="textgreen-300">"红色"</span>); <span class="textblue-300">// 直接调用三参数构造函数</span><br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"\n=== 继承构造函数示例 ==="</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Circle circle1(<span class="textgreen-300">"圆形A"</span>); <span class="textblue-300">// 使用继承的构造函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Circle circle2(<span class="textgreen-300">"圆形B"</span>, 123); <span class="textblue-300">// 使用继承的构造函数</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Circle circle3(5.0); <span class="textblue-300">// 使用Circle自己的构造函数</span><br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"\n=== 矩形信息 ==="</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;rect1.printInfo();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;rect2.printInfo();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;rect3.printInfo();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;rect4.printInfo();<br>
                        }<br>
                        <br>
                        <span class="textpurple-400">int</span> main() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;constructor_examples();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> 0;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 27. final/override控制 -->
        <section id="section-27" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">27. final/override控制</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - final/override控制 (final/override control)</h4>
                <p class="text-slate-300 mb-4">特点：override关键字确保派生类函数重写基类虚函数，提供编译时检查；final关键字防止类被继承或虚函数被重写。注意事项：使用override可以避免因函数签名不匹配导致的错误；final用于限制继承层次结构。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># final/override控制的使用</div>
                    <div class="text-sm leading-6">
                        <span class="textblue-300">#include &lt;iostream&gt;</span><br>
                        <span class="textblue-300">#include &lt;string&gt;</span><br>
                        <br>
                        <span class="textpurple-400">class</span> <span class="textblue-300">Animal</span> {<br>
                        <span class="textpurple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">virtual</span> <span class="textpurple-400">void</span> speak() <span class="textpurple-400">const</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"动物发出声音"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">virtual</span> <span class="textpurple-400">void</span> move() <span class="textpurple-400">const</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"动物移动"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">virtual</span> <span class="textpurple-400">std::string</span> getName() <span class="textpurple-400">const</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> <span class="textgreen-300">"未知动物"</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">virtual</span> ~Animal() = <span class="textpurple-400">default</span>;<br>
                        };<br>
                        <br>
                        <span class="textpurple-400">class</span> <span class="textblue-300">Dog</span> : <span class="textpurple-400">public</span> Animal {<br>
                        <span class="textpurple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">void</span> speak() <span class="textpurple-400">const</span> <span class="textpurple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"狗: 汪汪!"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">void</span> move() <span class="textpurple-400">const</span> <span class="textpurple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"狗跑得很快"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">std::string</span> getName() <span class="textpurple-400">const</span> <span class="textpurple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> <span class="textgreen-300">"狗"</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 使用final防止这个函数被进一步重写</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">void</span> bark() <span class="textpurple-400">const</span> <span class="textpurple-400">final</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"特定的狗叫声"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        };<br>
                        <br>
                        <span class="textpurple-400">class</span> <span class="textblue-300">Cat</span> : <span class="textpurple-400">public</span> Animal {<br>
                        <span class="textpurple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">void</span> speak() <span class="textpurple-400">const</span> <span class="textpurple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"猫: 喵喵!"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">void</span> move() <span class="textpurple-400">const</span> <span class="textpurple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"猫优雅地走"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">std::string</span> getName() <span class="textpurple-400">const</span> <span class="textpurple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> <span class="textgreen-300">"猫"</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        };<br>
                        <br>
                        <span class="textpurple-400">class</span> <span class="textblue-300">GoldenRetriever</span> : <span class="textpurple-400">public</span> Dog {<br>
                        <span class="textpurple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">void</span> speak() <span class="textpurple-400">const</span> <span class="textpurple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"金毛: 汪汪汪!"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">void</span> move() <span class="textpurple-400">const</span> <span class="textpurple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"金毛跑得特别开心"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 不能重写Dog的bark()函数，因为它是final的</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// void bark() const override { } // 这会引发编译错误</span><br>
                        };<br>
                        <br>
                        <span class="textpurple-400">class</span> <span class="textblue-300">SpecialDog</span> : <span class="textpurple-400">public</span> Dog {<br>
                        <span class="textpurple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">void</span> speak() <span class="textpurple-400">const</span> <span class="textpurple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"特殊狗: 汪!"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        };<br>
                        <br>
                        <span class="textpurple-400">class</span> <span class="textblue-300">FinalDog</span> final : <span class="textpurple-400">public</span> SpecialDog {<br>
                        <span class="textpurple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">void</span> speak() <span class="textpurple-400">const</span> <span class="textpurple-400">override</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"终极狗: 汪汪汪汪!"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// FinalDog不能被继承，因为它是final的</span><br>
                        };<br>
                        <br>
                        <span class="textpurple-400">void</span> <span class="textyellow-300">override_final_examples</span>() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"=== 基类Animal示例 ==="</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Animal animal;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;animal.speak();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;animal.move();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"名称: "</span> &lt;&lt; animal.getName() &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"\n=== Dog类示例 ==="</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Dog dog;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;dog.speak();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;dog.move();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"名称: "</span> &lt;&lt; dog.getName() &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;dog.bark();<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"\n=== Cat类示例 ==="</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Cat cat;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;cat.speak();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;cat.move();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"名称: "</span> &lt;&lt; cat.getName() &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"\n=== GoldenRetriever类示例 ==="</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;GoldenRetriever golden;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;golden.speak();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;golden.move();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"名称: "</span> &lt;&lt; golden.getName() &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"\n=== 多态性示例 ==="</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Animal* animals[] = {&amp;animal, &amp;dog, &amp;cat, &amp;golden};<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">for</span> (<span class="textpurple-400">int</span> i = 0; i &lt; 4; ++i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animals[i]-&gt;speak();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animals[i]-&gt;move();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"名称: "</span> &lt;&lt; animals[i]-&gt;getName() &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"---"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        }<br>
                        <br>
                        <span class="textpurple-400">int</span> main() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;override_final_examples();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> 0;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 28. 原子操作 -->
        <section id="section-28" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">28. 原子操作</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 原子操作 (Atomic Operations)</h4>
                <p class="text-slate-300 mb-4">特点：原子操作保证操作的不可分割性，避免多线程环境下的数据竞争；提供内存顺序控制选项。注意事项：适用于需要线程安全但又不想使用互斥锁的简单操作；注意选择合适的内存顺序以平衡性能和安全性。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 原子操作的使用</div>
                    <div class="text-sm leading-6">
                        <span class="textblue-300">#include &lt;iostream&gt;</span><br>
                        <span class="textblue-300">#include &lt;thread&gt;</span><br>
                        <span class="textblue-300">#include &lt;vector&gt;</span><br>
                        <span class="textblue-300">#include &lt;atomic&gt;</span><br>
                        <span class="textblue-300">#include &lt;chrono&gt;</span><br>
                        <br>
                        <span class="textpurple-400">class</span> <span class="textblue-300">Counter</span> {<br>
                        <span class="textpurple-400">private</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::atomic&lt;<span class="textpurple-400">int</span>&gt; count{0};<br>
                        <br>
                        <span class="textpurple-400">public</span>:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">void</span> increment() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count.fetch_add(1, std::memory_order_relaxed);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">int</span> get() <span class="textpurple-400">const</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> count.load();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">void</span> reset() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count.store(0);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        };<br>
                        <br>
                        <span class="textpurple-400">void</span> <span class="textyellow-300">atomic_examples</span>() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"=== 原子操作示例 ==="</span> &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 基本原子类型操作</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::atomic&lt;<span class="textpurple-400">int</span>&gt; atomic_int{0};<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::atomic&lt;<span class="textpurple-400">bool</span>&gt; atomic_bool{<span class="textpurple-400">false</span>};<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::atomic&lt;<span class="textpurple-400">long</span>&gt; atomic_long{100};<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 原子加法操作</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;atomic_int.fetch_add(5);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"原子加法后: "</span> &lt;&lt; atomic_int.load() &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 原子减法操作</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;atomic_int.fetch_sub(2);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"原子减法后: "</span> &lt;&lt; atomic_int.load() &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 原子比较交换操作</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">int</span> expected = 3;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">int</span> desired = 10;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">bool</span> success = atomic_int.compare_exchange_strong(expected, desired);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"比较交换: "</span> &lt;&lt; (success ? <span class="textgreen-300">"成功"</span> : <span class="textgreen-300">"失败"</span>) &lt;&lt; <span class="textgreen-300">", 值: "</span> &lt;&lt; atomic_int.load() &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 使用自定义Counter类</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Counter counter;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;std::thread&gt; threads;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 创建多个线程来增加计数器</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">const</span> <span class="textpurple-400">int</span> num_threads = 5;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">const</span> <span class="textpurple-400">int</span> increments_per_thread = 1000;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">for</span> (<span class="textpurple-400">int</span> i = 0; i &lt; num_threads; ++i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threads.emplace_back([&amp;counter]() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">for</span> (<span class="textpurple-400">int</span> j = 0; j &lt; increments_per_thread; ++j) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter.increment();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 等待所有线程完成</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">for</span> (<span class="textpurple-400">auto</span>&amp; t : threads) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.join();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"多线程计数器结果: "</span> &lt;&lt; counter.get() &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"预期结果: "</span> &lt;&lt; num_threads * increments_per_thread &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 原子标志示例</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::atomic_flag flag = ATOMIC_FLAG_INIT;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">if</span> (flag.test_and_set()) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"标志已被设置"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;} <span class="textpurple-400">else</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"标志未被设置，现在设置"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag.clear();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 内存顺序示例</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::atomic&lt;<span class="textpurple-400">int</span>&gt; relaxed_counter{0};<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::atomic&lt;<span class="textpurple-400">int</span>&gt; acquire_counter{0};<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::atomic&lt;<span class="textpurple-400">int</span>&gt; release_counter{0};<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;relaxed_counter.store(1, std::memory_order_relaxed);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;acquire_counter.store(2, std::memory_order_acquire);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;release_counter.store(3, std::memory_order_release);<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"内存顺序示例 - Relaxed: "</span> &lt;&lt; relaxed_counter.load(std::memory_order_relaxed) &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"内存顺序示例 - Acquire: "</span> &lt;&lt; acquire_counter.load(std::memory_order_acquire) &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"内存顺序示例 - Release: "</span> &lt;&lt; release_counter.load(std::memory_order_release) &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 使用原子操作实现简单的锁</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::atomic&lt;<span class="textpurple-400">bool</span>&gt; lock_flag{<span class="textpurple-400">false</span>};<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">auto</span> lock_func = [&amp;lock_flag]() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">bool</span> expected = <span class="textpurple-400">false</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">while</span> (!lock_flag.compare_exchange_weak(expected, <span class="textpurple-400">true</span>)) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expected = <span class="textpurple-400">false</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::this_thread::sleep_for(std::chrono::microseconds(1));<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;};<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">auto</span> unlock_func = [&amp;lock_flag]() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock_flag.store(<span class="textpurple-400">false</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;};<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"原子锁示例 - 锁定/解锁操作演示完成"</span> &lt;&lt; std::endl;<br>
                        }<br>
                        <br>
                        <span class="textpurple-400">int</span> main() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;atomic_examples();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> 0;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 29. chrono时间库 -->
        <section id="section-29" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">29. chrono时间库</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - chrono时间库 (chrono Time Library)</h4>
                <p class="text-slate-300 mb-4">特点：提供高精度时间处理能力，包括duration、time_point等类型；支持各种时间单位的转换；提供时钟类型如steady_clock、system_clock等。注意事项：使用steady_clock可以获得单调递增的时间；duration支持各种时间单位的自动转换；适合需要精确时间测量的应用。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># chrono时间库的使用</div>
                    <div class="text-sm leading-6">
                        <span class="textblue-300">#include &lt;iostream&gt;</span><br>
                        <span class="textblue-300">#include &lt;chrono&gt;</span><br>
                        <span class="textblue-300">#include &lt;thread&gt;</span><br>
                        <span class="textblue-300">#include &lt;ctime&gt;</span><br>
                        <span class="textblue-300">#include &lt;ratio&gt;</span><br>
                        <br>
                        <span class="textpurple-400">void</span> <span class="textyellow-300">chrono_examples</span>() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"=== chrono时间库示例 ==="</span> &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 基本duration类型</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::duration&lt;<span class="textpurple-400">int</span>&gt; one_second(1);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::duration&lt;<span class="textpurple-400">double</span>, std::ratio&lt;1, 1000&gt;&gt; one_millisecond(1000.0);<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"1秒 = "</span> &lt;&lt; one_second.count() &lt;&lt; <span class="textgreen-300">" 秒"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"1毫秒 = "</span> &lt;&lt; one_millisecond.count() &lt;&lt; <span class="textgreen-300">" 毫秒"</span> &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 使用预定义的时间单位</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::seconds sec(5);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::milliseconds ms(5000);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::microseconds us(5000000);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::nanoseconds ns(5000000000);<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"5秒 = "</span> &lt;&lt; ms.count() &lt;&lt; <span class="textgreen-300">" 毫秒"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"5秒 = "</span> &lt;&lt; us.count() &lt;&lt; <span class="textgreen-300">" 微秒"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"5秒 = "</span> &lt;&lt; ns.count() &lt;&lt; <span class="textgreen-300">" 纳秒"</span> &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 时间单位转换</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::duration&lt;<span class="textpurple-400">double</span>, std::ratio&lt;60&gt;&gt; one_minute(1.5);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::duration&lt;<span class="textpurple-400">double</span>&gt; in_seconds = one_minute;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"1.5分钟 = "</span> &lt;&lt; in_seconds.count() &lt;&lt; <span class="textgreen-300">" 秒"</span> &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 使用time_point</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">auto</span> start = std::chrono::high_resolution_clock::now();<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 模拟一些工作</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::this_thread::sleep_for(std::chrono::milliseconds(100));<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">auto</span> end = std::chrono::high_resolution_clock::now();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::duration&lt;<span class="textpurple-400">double</span>, std::milli&gt; elapsed = end - start;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"执行时间: "</span> &lt;&lt; elapsed.count() &lt;&lt; <span class="textgreen-300">" 毫秒"</span> &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 不同时钟类型</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">auto</span> system_time = std::chrono::system_clock::now();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">auto</span> steady_time = std::chrono::steady_clock::now();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">auto</span> high_res_time = std::chrono::high_resolution_clock::now();<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::time_t system_time_t = std::chrono::system_clock::to_time_t(system_time);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"系统时间: "</span> &lt;&lt; std::ctime(&amp;system_time_t);<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// duration的算术运算</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::seconds duration1(10);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::milliseconds duration2(5000);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::milliseconds total = duration1 + duration2;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"总时间: "</span> &lt;&lt; total.count() &lt;&lt; <span class="textgreen-300">" 毫秒"</span> &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 比较duration</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">if</span> (duration1 &gt; duration2) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"duration1 大于 duration2"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;} <span class="textpurple-400">else</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"duration1 不大于 duration2"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 使用ratio进行自定义时间单位</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::duration&lt;<span class="textpurple-400">int</span>, std::ratio&lt;3600&gt;&gt; one_hour(1);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::duration&lt;<span class="textpurple-400">int</span>, std::ratio&lt;60&gt;&gt; two_minutes(2);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"1小时 = "</span> &lt;&lt; one_hour.count() &lt;&lt; <span class="textgreen-300">" 秒"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"2分钟 = "</span> &lt;&lt; two_minutes.count() &lt;&lt; <span class="textgreen-300">" 秒"</span> &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 精确计时示例</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"\n=== 精确计时示例 ==="</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">auto</span> precise_start = std::chrono::high_resolution_clock::now();<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 计算简单循环的执行时间</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">volatile</span> <span class="textpurple-400">int</span> sum = 0;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">for</span> (<span class="textpurple-400">int</span> i = 0; i &lt; 1000000; ++i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum += i;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">auto</span> precise_end = std::chrono::high_resolution_clock::now();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::duration&lt;<span class="textpurple-400">double</span>, std::nano&gt; precise_elapsed = precise_end - precise_start;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"循环执行时间: "</span> &lt;&lt; precise_elapsed.count() &lt;&lt; <span class="textgreen-300">" 纳秒"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"循环执行时间: "</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(precise_elapsed).count() &lt;&lt; <span class="textgreen-300">" 微秒"</span> &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 时间点计算</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::time_point&lt;std::chrono::system_clock&gt; now = std::chrono::system_clock::now();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::time_point&lt;std::chrono::system_clock&gt; one_hour_later = now + std::chrono::hours(1);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::chrono::time_point&lt;std::chrono::system_clock&gt; two_hours_earlier = now - std::chrono::hours(2);<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::time_t now_time = std::chrono::system_clock::to_time_t(now);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::time_t later_time = std::chrono::system_clock::to_time_t(one_hour_later);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"当前时间: "</span> &lt;&lt; std::ctime(&amp;now_time);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"一小时后: "</span> &lt;&lt; std::ctime(&amp;later_time);<br>
                        }<br>
                        <br>
                        <span class="textpurple-400">int</span> main() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;chrono_examples();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> 0;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 30. 随机数库 -->
        <section id="section-30" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">30. 随机数库</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 随机数库 (Random Number Library)</h4>
                <p class="text-slate-300 mb-4">特点：提供高质量的随机数生成器，包括线性同余、梅森旋转等算法；支持多种概率分布如均匀分布、正态分布等；比传统rand()函数更可靠。注意事项：选择合适的随机数引擎和分布；需要设置种子以获得不同的随机序列；注意线程安全问题。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 随机数库的使用</div>
                    <div class="text-sm leading-6">
                        <span class="textblue-300">#include &lt;iostream&gt;</span><br>
                        <span class="textblue-300">#include &lt;random&gt;</span><br>
                        <span class="textblue-300">#include &lt;vector&gt;</span><br>
                        <span class="textblue-300">#include &lt;map&gt;</span><br>
                        <span class="textblue-300">#include &lt;chrono&gt;</span><br>
                        <br>
                        <span class="textpurple-400">void</span> <span class="textyellow-300">random_examples</span>() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"=== 随机数库示例 ==="</span> &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 使用不同的随机数引擎</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::default_random_engine engine1;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::mt19937 engine2; <span class="textblue-300">// 梅森旋转算法</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::ranlux24_base engine3; <span class="textblue-300">// 高质量但较慢的引擎</span><br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 设置种子</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::random_device rd; <span class="textblue-300">// 真随机数设备</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;engine1.seed(rd());<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;engine2.seed(std::chrono::high_resolution_clock::now().time_since_epoch().count());<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 均匀整数分布</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::uniform_int_distribution&lt;<span class="textpurple-400">int</span>&gt; uniform_dist(1, 100);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"均匀整数分布 (1-100): "</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">for</span> (<span class="textpurple-400">int</span> i = 0; i &lt; 5; ++i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; uniform_dist(engine1) &lt;&lt; <span class="textgreen-300">" "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 均匀实数分布</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::uniform_real_distribution&lt;<span class="textpurple-400">double</span>&gt; real_dist(0.0, 1.0);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"均匀实数分布 (0.0-1.0): "</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">for</span> (<span class="textpurple-400">int</span> i = 0; i &lt; 5; ++i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; real_dist(engine2) &lt;&lt; <span class="textgreen-300">" "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 正态分布</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::normal_distribution&lt;<span class="textpurple-400">double</span>&gt; normal_dist(0.0, 1.0); <span class="textblue-300">// 均值0，标准差1</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"正态分布 (均值0，标准差1): "</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">for</span> (<span class="textpurple-400">int</span> i = 0; i &lt; 5; ++i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; normal_dist(engine1) &lt;&lt; <span class="textgreen-300">" "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 伯努利分布</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::bernoulli_distribution bernoulli_dist(0.3); <span class="textblue-300">// 30%概率为true</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"伯努利分布 (30%概率): "</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">for</span> (<span class="textpurple-400">int</span> i = 0; i &lt; 10; ++i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; (bernoulli_dist(engine2) ? <span class="textgreen-300">"true"</span> : <span class="textgreen-300">"false"</span>) &lt;&lt; <span class="textgreen-300">" "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 二项分布</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::binomial_distribution&lt;<span class="textpurple-400">int</span>&gt; binomial_dist(10, 0.5); <span class="textblue-300">// 10次试验，成功率0.5</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"二项分布 (10次试验，成功率0.5): "</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">for</span> (<span class="textpurple-400">int</span> i = 0; i &lt; 5; ++i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; binomial_dist(engine1) &lt;&lt; <span class="textgreen-300">" "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 泊松分布</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::poisson_distribution&lt;<span class="textpurple-400">int</span>&gt; poisson_dist(2.5); <span class="textblue-300">// 平均值2.5</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"泊松分布 (平均值2.5): "</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">for</span> (<span class="textpurple-400">int</span> i = 0; i &lt; 5; ++i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; poisson_dist(engine2) &lt;&lt; <span class="textgreen-300">" "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 指数分布</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::exponential_distribution&lt;<span class="textpurple-400">double</span>&gt; exponential_dist(1.0);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"指数分布 (λ=1.0): "</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">for</span> (<span class="textpurple-400">int</span> i = 0; i &lt; 5; ++i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; exponential_dist(engine1) &lt;&lt; <span class="textgreen-300">" "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 洗牌算法示例</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;<span class="textpurple-400">int</span>&gt; numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"原始数组: "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">for</span> (<span class="textpurple-400">int</span> n : numbers) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; n &lt;&lt; <span class="textgreen-300">" "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::shuffle(numbers.begin(), numbers.end(), engine2);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"洗牌后数组: "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">for</span> (<span class="textpurple-400">int</span> n : numbers) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; n &lt;&lt; <span class="textgreen-300">" "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 随机选择示例</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;std::string&gt; options = {<span class="textgreen-300">"苹果"</span>, <span class="textgreen-300">"香蕉"</span>, <span class="textgreen-300">"橙子"</span>, <span class="textgreen-300">"葡萄"</span>, <span class="textgreen-300">"草莓"</span>};<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::uniform_int_distribution&lt;&span class="textpurple-400">int</span>&gt; option_dist(0, options.size() - 1);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"随机选择的水果: "</span> &lt;&lt; options[option_dist(engine1)] &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 模拟掷骰子</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::uniform_int_distribution&lt;<span class="textpurple-400">int</span>&gt; dice_dist(1, 6);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"掷骰子10次: "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">for</span> (<span class="textpurple-400">int</span> i = 0; i &lt; 10; ++i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; dice_dist(engine2) &lt;&lt; <span class="textgreen-300">" "</span>;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl;<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 统计分布示例</span><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::map&lt;<span class="textpurple-400">int</span>, <span class="textpurple-400">int</span>&gt; counts;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::uniform_int_distribution&lt;<span class="textpurple-400">int</span>&gt; stats_dist(1, 6);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">for</span> (<span class="textpurple-400">int</span> i = 0; i &lt; 1000; ++i) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counts[stats_dist(engine1)]++;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"1000次掷骰子统计: "</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">for</span> (<span class="textpurple-400">const</span> <span class="textpurple-400">auto</span>&amp; pair : counts) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"点数 "</span> &lt;&lt; pair.first &lt;&lt; <span class="textgreen-300">": "</span> &lt;&lt; pair.second &lt;&lt; <span class="textgreen-300">" 次"</span> &lt;&lt; std::endl;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        }<br>
                        <br>
                        <span class="textpurple-400">int</span> main() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;random_examples();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">return</span> 0;<br>
                        }
                    </div>
                </div>
            </div>
        </section>

        <!-- 31. 新的算法和容器 -->
        <section id="section-31" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">31. 新的算法和容器</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - C++11新增的算法和容器</h4>
                <p class="text-slate-300 mb-4">特点：C++11标准引入了新的STL容器和算法，增强了标准库功能。注意事项：包括std::array、std::unordered_set、std::unordered_map等容器，以及std::begin/std::end、std::all_of/any_of/none_of等算法。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># 新的算法和容器</div>
                    <div class="text-sm leading-6">
                        <span class="textblue-300">// std::array - 固定大小的数组容器</span><br>
                        std::array&lt;int, 5&gt; arr = {1, 2, 3, 4, 5};<br>
                        std::cout &lt;&lt; <span class="textgreen-300">"数组大小: "</span> &lt;&lt; arr.size() &lt;&lt; std::endl;<br>
                        <br>
                        <span class="textblue-300">// std::unordered_set - 哈希集合</span><br>
                        std::unordered_set&lt;int&gt; hash_set = {1, 2, 3, 4, 5};<br>
                        hash_set.insert(6);<br>
                        <span class="textpurple-400">if</span> (hash_set.count(3)) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"找到元素3"</span> &lt;&lt; std::endl;<br>
                        }<br>
                        <br>
                        <span class="textblue-300">// std::unordered_map - 哈希映射</span><br>
                        std::unordered_map&lt;std::string, int&gt; hash_map = {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;{<span class="textgreen-300">"apple"</span>, 1},<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;{<span class="textgreen-300">"banana"</span>, 2},<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;{<span class="textgreen-300">"orange"</span>, 3}<br>
                        };<br>
                        std::cout &lt;&lt; <span class="textgreen-300">"apple的值: "</span> &lt;&lt; hash_map[<span class="textgreen-300">"apple"</span>] &lt;&lt; std::endl;<br>
                        <br>
                        <span class="textblue-300">// std::forward_list - 单向链表</span><br>
                        std::forward_list&lt;int&gt; flist = {1, 2, 3, 4, 5};<br>
                        flist.push_front(0);<br>
                        <br>
                        <span class="textblue-300">// std::begin和std::end算法</span><br>
                        std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};<br>
                        <span class="textpurple-400">auto</span> it = std::find(std::begin(vec), std::end(vec), 3);<br>
                        <span class="textpurple-400">if</span> (it != std::end(vec)) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; <span class="textgreen-300">"找到元素: "</span> &lt;&lt; *it &lt;&lt; std::endl;<br>
                        }<br>
                        <br>
                        <span class="textblue-300">// C++11算法 - all_of, any_of, none_of</span><br>
                        std::vector&lt;int&gt; numbers = {2, 4, 6, 8};<br>
                        <span class="textpurple-400">bool</span> all_even = std::all_of(std::begin(numbers), std::end(numbers),<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](int n) { <span class="textpurple-400">return</span> n % 2 == 0; });<br>
                        std::cout &lt;&lt; <span class="textgreen-300">"所有数字都是偶数: "</span> &lt;&lt; all_even &lt;&lt; std::endl;<br>
                        <br>
                        <span class="textpurple-400">bool</span> any_odd = std::any_of(std::begin(numbers), std::end(numbers),<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](int n) { <span class="textpurple-400">return</span> n % 2 == 1; });<br>
                        std::cout &lt;&lt; <span class="textgreen-300">"存在奇数: "</span> &lt;&lt; any_odd &lt;&lt; std::endl;<br>
                        <br>
                        <span class="textblue-300">// std::iota - 生成连续序列</span><br>
                        std::vector&lt;int&gt; sequence(10);<br>
                        std::iota(std::begin(sequence), std::end(sequence), 1); <span class="textblue-300">// 生成1-10</span><br>
                        std::cout &lt;&lt; <span class="textgreen-300">"连续序列: "</span>;<br>
                        <span class="textpurple-400">for</span> (<span class="textpurple-400">int</span> n : sequence) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; n &lt;&lt; <span class="textgreen-300">" "</span>;<br>
                        }<br>
                        std::cout &lt;&lt; std::endl;<br>
                        <br>
                        <span class="textblue-300">// std::copy_if - 条件复制</span><br>
                        std::vector&lt;int&gt; source = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};<br>
                        std::vector&lt;int&gt; evens;<br>
                        std::copy_if(std::begin(source), std::end(source),<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::back_inserter(evens),<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](int n) { <span class="textpurple-400">return</span> n % 2 == 0; });<br>
                        std::cout &lt;&lt; <span class="textgreen-300">"偶数: "</span>;<br>
                        <span class="textpurple-400">for</span> (<span class="textpurple-400">int</span> n : evens) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; n &lt;&lt; <span class="textgreen-300">" "</span>;<br>
                        }<br>
                        std::cout &lt;&lt; std::endl;<br>
                        <br>
                        <span class="textblue-300">// std::move - 移动算法</span><br>
                        std::vector&lt;int&gt; source2 = {1, 2, 3, 4, 5};<br>
                        std::vector&lt;int&gt; target(5);<br>
                        std::move(std::begin(source2), std::end(source2), std::begin(target));<br>
                        std::cout &lt;&lt; <span class="textgreen-300">"移动后目标容器: "</span>;<br>
                        <span class="textpurple-400">for</span> (<span class="textpurple-400">int</span> n : target) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; n &lt;&lt; <span class="textgreen-300">" "</span>;<br>
                        }<br>
                        std::cout &lt;&lt; std::endl;
                    </div>
                </div>
            </div>
        </section>

        <!-- 32. static_assert和类型特质 -->
        <section id="section-32" class="mb-16">
            <h2 class="text-3xl font-bold mb-8 text-center">
                <span class="gradient-text">32. static_assert和类型特质</span>
            </h2>
            
            <div class="language-content" data-lang="cpp">
                <h4 class="text-lg font-medium mb-4 text-purple-400">C++ - 静态断言和类型特质</h4>
                <p class="text-slate-300 mb-4">特点：C++11引入了static_assert进行编译时断言检查，以及类型特质库(std::tr1)进行编译时类型检查。注意事项：static_assert在编译时验证条件，类型特质提供编译时类型信息。</p>
                
                <div class="code-block rounded-lg p-4 code-font text-sm">
                    <div class="text-slate-400 mb-2"># static_assert和类型特质</div>
                    <div class="text-sm leading-6">
                        <span class="textblue-300">// static_assert - 编译时断言</span><br>
                        <span class="textpurple-400">template</span>&lt;<span class="textpurple-400">typename</span> T&gt;<br>
                        <span class="textpurple-400">void</span> process_data(T&amp; data) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;static_assert(<span class="textpurple-400">sizeof</span>(T) &gt;= 4, <span class="textgreen-300">"类型大小必须至少为4字节"</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textblue-300">// 处理数据</span><br>
                        }<br>
                        <br>
                        <span class="textblue-300">// 验证整数类型</span><br>
                        <span class="textpurple-400">template</span>&lt;<span class="textpurple-400">typename</span> T&gt;<br>
                        <span class="textpurple-400">void</span> check_integer() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;static_assert(std::is_integral&lt;T&gt;::value, <span class="textgreen-300">"类型必须是整数类型"</span>);<br>
                        }<br>
                        <br>
                        <span class="textblue-300">// 验证指针类型</span><br>
                        <span class="textpurple-400">template</span>&lt;<span class="textpurple-400">typename</span> T&gt;<br>
                        <span class="textpurple-400">struct</span> is_pointer_helper {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">static</span> <span class="textpurple-400">const</span> <span class="textpurple-400">bool</span> value = std::is_pointer&lt;T&gt;::value;<br>
                        };<br>
                        <br>
                        <span class="textblue-300">// 类型特质 - 基本类型检查</span><br>
                        <span class="textpurple-400">static_assert</span>(std::is_integral&lt;int&gt;::value, <span class="textgreen-300">"int是整数类型"</span>);<br>
                        <span class="textpurple-400">static_assert</span>(std::is_floating_point&lt;double&gt;::value, <span class="textgreen-300">"double是浮点类型"</span>);<br>
                        <span class="textpurple-400">static_assert</span>(std::is_arithmetic&lt;float&gt;::value, <span class="textgreen-300">"float是算术类型"</span>);<br>
                        <br>
                        <span class="textblue-300">// 类型特质 - 复合类型检查</span><br>
                        <span class="textpurple-400">static_assert</span>(std::is_pointer&lt;<span class="textpurple-400">int</span>*&gt;::value, <span class="textgreen-300">"int*是指针类型"</span>);<br>
                        <span class="textpurple-400">static_assert</span>(std::is_reference&lt;<span class="textpurple-400">int</span>&amp;&gt;::value, <span class="textgreen-300">"int&amp;是引用类型"</span>);<br>
                        <span class="textpurple-400">static_assert</span>(std::is_lvalue_reference&lt;<span class="textpurple-400">int</span>&amp;&gt;::value, <span class="textgreen-300">"int&amp;是左值引用"</span>);<br>
                        <br>
                        <span class="textblue-300">// 类型特质 - 函数类型检查</span><br>
                        <span class="textpurple-400">static_assert</span>(std::is_function&lt;<span class="textpurple-400">void</span>(<span class="textpurple-400">int</span>, <span class="textpurple-400">double</span>)&gt;::value, <span class="textgreen-300">"void(int, double)是函数类型"</span>);<br>
                        <br>
                        <span class="textblue-300">// 类型转换特质</span><br>
                        <span class="textpurple-400">static_assert</span>(std::is_convertible&lt;<span class="textpurple-400">int</span>, <span class="textpurple-400">double</span>&gt;::value, <span class="textgreen-300">"int可转换为double"</span>);<br>
                        <br>
                        <span class="textblue-300">// cv限定符检查</span><br>
                        <span class="textpurple-400">static_assert</span>(std::is_const&lt;<span class="textpurple-400">const</span> <span class="textpurple-400">int</span>&gt;::value, <span class="textgreen-300">"const int有const限定符"</span>);<br>
                        <span class="textpurple-400">static_assert</span>(std::is_volatile&lt;volatile <span class="textpurple-400">int</span>&gt;::value, <span class="textgreen-300">"volatile int有volatile限定符"</span>);<br>
                        <br>
                        <span class="textblue-300">// 复合类型特质</span><br>
                        <span class="textpurple-400">struct</span> MyStruct {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">int</span> x;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="textpurple-400">double</span> y;<br>
                        };<br>
                        <span class="textpurple-400">static_assert</span>(std::is_class&lt;MyStruct&gt;::value, <span class="textgreen-300">"MyStruct是类类型"</span>);<br>
                        <span class="textpurple-400">static_assert</span>(std::is_pod&lt;MyStruct&gt;::value, <span class="textgreen-300">"MyStruct是POD类型"</span>);<br>
                        <br>
                        <span class="textblue-300">// 对象大小验证</span><br>
                        <span class="textpurple-400">static_assert</span>(std::alignment_of&lt;<span class="textpurple-400">double</span>&gt;::value &gt;= 4, <span class="textgreen-300">"double的对齐要求至少为4"</span>);<br>
                        <br>
                        <span class="textblue-300">// 实际使用示例</span><br>
                        <span class="textpurple-400">template</span>&lt;<span class="textpurple-400">typename</span> T&gt;<br>
                        <span class="textpurple-400">void</span> safe_copy(T&amp; dest, <span class="textpurple-400">const</span> T&amp; src) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;static_assert(std::is_trivially_copyable&lt;T&gt;::value, <span class="textgreen-300">"类型必须可平凡复制"</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;dest = src; <span class="textblue-300">// 安全的复制操作</span><br>
                        }
                    </div>
                </div>
            </div>
        </section>
    </div>
</div>
    </main>
    <script src="static/js/theme.js"></script>
</body>
</html>